// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryParamsRequest)
pub struct QueryParamsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryParamsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryParamsRequest {
    fn default() -> &'a QueryParamsRequest {
        <QueryParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsRequest {
    pub fn new() -> QueryParamsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryParamsRequest>(
            "QueryParamsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryParamsRequest {
        QueryParamsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryParamsRequest {
        static instance: QueryParamsRequest = QueryParamsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryParamsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryParamsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryParamsResponse)
pub struct QueryParamsResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryParamsResponse.params)
    pub params: ::protobuf::MessageField<super::liquidity::Params>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryParamsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryParamsResponse {
    fn default() -> &'a QueryParamsResponse {
        <QueryParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsResponse {
    pub fn new() -> QueryParamsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::liquidity::Params>(
            "params",
            |m: &QueryParamsResponse| { &m.params },
            |m: &mut QueryParamsResponse| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryParamsResponse>(
            "QueryParamsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.params.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryParamsResponse {
        QueryParamsResponse::new()
    }

    fn clear(&mut self) {
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryParamsResponse {
        static instance: QueryParamsResponse = QueryParamsResponse {
            params: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryParamsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryParamsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolsRequest is request type for the Query/Pools RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolsRequest)
pub struct QueryPoolsRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolsRequest.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolsRequest.disabled)
    pub disabled: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolsRequest {
    fn default() -> &'a QueryPoolsRequest {
        <QueryPoolsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolsRequest {
    pub fn new() -> QueryPoolsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &QueryPoolsRequest| { &m.pair_id },
            |m: &mut QueryPoolsRequest| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled",
            |m: &QueryPoolsRequest| { &m.disabled },
            |m: &mut QueryPoolsRequest| { &mut m.disabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryPoolsRequest| { &m.pagination },
            |m: &mut QueryPoolsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolsRequest>(
            "QueryPoolsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolsRequest {
    const NAME: &'static str = "QueryPoolsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pair_id = is.read_uint64()?;
                },
                18 => {
                    self.disabled = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pair_id);
        }
        if !self.disabled.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.disabled);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pair_id != 0 {
            os.write_uint64(1, self.pair_id)?;
        }
        if !self.disabled.is_empty() {
            os.write_string(2, &self.disabled)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolsRequest {
        QueryPoolsRequest::new()
    }

    fn clear(&mut self) {
        self.pair_id = 0;
        self.disabled.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolsRequest {
        static instance: QueryPoolsRequest = QueryPoolsRequest {
            pair_id: 0,
            disabled: ::std::string::String::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolsResponse is response type for the Query/Pools RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolsResponse)
pub struct QueryPoolsResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolsResponse.pools)
    pub pools: ::std::vec::Vec<PoolResponse>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolsResponse {
    fn default() -> &'a QueryPoolsResponse {
        <QueryPoolsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolsResponse {
    pub fn new() -> QueryPoolsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pools",
            |m: &QueryPoolsResponse| { &m.pools },
            |m: &mut QueryPoolsResponse| { &mut m.pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryPoolsResponse| { &m.pagination },
            |m: &mut QueryPoolsResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolsResponse>(
            "QueryPoolsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolsResponse {
    const NAME: &'static str = "QueryPoolsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pools.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pools {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolsResponse {
        QueryPoolsResponse::new()
    }

    fn clear(&mut self) {
        self.pools.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolsResponse {
        static instance: QueryPoolsResponse = QueryPoolsResponse {
            pools: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolRequest is request type for the Query/Pool RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolRequest)
pub struct QueryPoolRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolRequest.pool_id)
    pub pool_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolRequest {
    fn default() -> &'a QueryPoolRequest {
        <QueryPoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolRequest {
    pub fn new() -> QueryPoolRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &QueryPoolRequest| { &m.pool_id },
            |m: &mut QueryPoolRequest| { &mut m.pool_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolRequest>(
            "QueryPoolRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolRequest {
    const NAME: &'static str = "QueryPoolRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pool_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pool_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pool_id != 0 {
            os.write_uint64(1, self.pool_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolRequest {
        QueryPoolRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolRequest {
        static instance: QueryPoolRequest = QueryPoolRequest {
            pool_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolResponse is response type for the Query/Pool RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolResponse)
pub struct QueryPoolResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolResponse.pool)
    pub pool: ::protobuf::MessageField<PoolResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolResponse {
    fn default() -> &'a QueryPoolResponse {
        <QueryPoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolResponse {
    pub fn new() -> QueryPoolResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolResponse>(
            "pool",
            |m: &QueryPoolResponse| { &m.pool },
            |m: &mut QueryPoolResponse| { &mut m.pool },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolResponse>(
            "QueryPoolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolResponse {
    const NAME: &'static str = "QueryPoolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolResponse {
        QueryPoolResponse::new()
    }

    fn clear(&mut self) {
        self.pool.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolResponse {
        static instance: QueryPoolResponse = QueryPoolResponse {
            pool: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolByReserveAddressRequest is request type for the Query/PoolByReserveAddress RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolByReserveAddressRequest)
pub struct QueryPoolByReserveAddressRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolByReserveAddressRequest.reserve_address)
    pub reserve_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolByReserveAddressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolByReserveAddressRequest {
    fn default() -> &'a QueryPoolByReserveAddressRequest {
        <QueryPoolByReserveAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolByReserveAddressRequest {
    pub fn new() -> QueryPoolByReserveAddressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reserve_address",
            |m: &QueryPoolByReserveAddressRequest| { &m.reserve_address },
            |m: &mut QueryPoolByReserveAddressRequest| { &mut m.reserve_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolByReserveAddressRequest>(
            "QueryPoolByReserveAddressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolByReserveAddressRequest {
    const NAME: &'static str = "QueryPoolByReserveAddressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reserve_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.reserve_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.reserve_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.reserve_address.is_empty() {
            os.write_string(1, &self.reserve_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolByReserveAddressRequest {
        QueryPoolByReserveAddressRequest::new()
    }

    fn clear(&mut self) {
        self.reserve_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolByReserveAddressRequest {
        static instance: QueryPoolByReserveAddressRequest = QueryPoolByReserveAddressRequest {
            reserve_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolByReserveAddressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolByReserveAddressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolByReserveAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolByReserveAddressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPoolByPoolCoinDenomRequest is request type for the Query/PoolByPoolCoinDenom RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPoolByPoolCoinDenomRequest)
pub struct QueryPoolByPoolCoinDenomRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPoolByPoolCoinDenomRequest.pool_coin_denom)
    pub pool_coin_denom: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPoolByPoolCoinDenomRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPoolByPoolCoinDenomRequest {
    fn default() -> &'a QueryPoolByPoolCoinDenomRequest {
        <QueryPoolByPoolCoinDenomRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPoolByPoolCoinDenomRequest {
    pub fn new() -> QueryPoolByPoolCoinDenomRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_coin_denom",
            |m: &QueryPoolByPoolCoinDenomRequest| { &m.pool_coin_denom },
            |m: &mut QueryPoolByPoolCoinDenomRequest| { &mut m.pool_coin_denom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPoolByPoolCoinDenomRequest>(
            "QueryPoolByPoolCoinDenomRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPoolByPoolCoinDenomRequest {
    const NAME: &'static str = "QueryPoolByPoolCoinDenomRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pool_coin_denom = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.pool_coin_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pool_coin_denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.pool_coin_denom.is_empty() {
            os.write_string(1, &self.pool_coin_denom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPoolByPoolCoinDenomRequest {
        QueryPoolByPoolCoinDenomRequest::new()
    }

    fn clear(&mut self) {
        self.pool_coin_denom.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPoolByPoolCoinDenomRequest {
        static instance: QueryPoolByPoolCoinDenomRequest = QueryPoolByPoolCoinDenomRequest {
            pool_coin_denom: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPoolByPoolCoinDenomRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPoolByPoolCoinDenomRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPoolByPoolCoinDenomRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPoolByPoolCoinDenomRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPairsRequest is request type for the Query/Pairs RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPairsRequest)
pub struct QueryPairsRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairsRequest.denoms)
    pub denoms: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPairsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPairsRequest {
    fn default() -> &'a QueryPairsRequest {
        <QueryPairsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPairsRequest {
    pub fn new() -> QueryPairsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "denoms",
            |m: &QueryPairsRequest| { &m.denoms },
            |m: &mut QueryPairsRequest| { &mut m.denoms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryPairsRequest| { &m.pagination },
            |m: &mut QueryPairsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPairsRequest>(
            "QueryPairsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPairsRequest {
    const NAME: &'static str = "QueryPairsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.denoms.push(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.denoms {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.denoms {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPairsRequest {
        QueryPairsRequest::new()
    }

    fn clear(&mut self) {
        self.denoms.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPairsRequest {
        static instance: QueryPairsRequest = QueryPairsRequest {
            denoms: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPairsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPairsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPairsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPairsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPairsResponse is response type for the Query/Pairs RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPairsResponse)
pub struct QueryPairsResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairsResponse.pairs)
    pub pairs: ::std::vec::Vec<super::liquidity::Pair>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPairsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPairsResponse {
    fn default() -> &'a QueryPairsResponse {
        <QueryPairsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPairsResponse {
    pub fn new() -> QueryPairsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pairs",
            |m: &QueryPairsResponse| { &m.pairs },
            |m: &mut QueryPairsResponse| { &mut m.pairs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryPairsResponse| { &m.pagination },
            |m: &mut QueryPairsResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPairsResponse>(
            "QueryPairsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPairsResponse {
    const NAME: &'static str = "QueryPairsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pairs.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pairs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPairsResponse {
        QueryPairsResponse::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPairsResponse {
        static instance: QueryPairsResponse = QueryPairsResponse {
            pairs: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPairsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPairsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPairsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPairsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPairRequest is request type for the Query/Pair RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPairRequest)
pub struct QueryPairRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairRequest.pair_id)
    pub pair_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPairRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPairRequest {
    fn default() -> &'a QueryPairRequest {
        <QueryPairRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPairRequest {
    pub fn new() -> QueryPairRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &QueryPairRequest| { &m.pair_id },
            |m: &mut QueryPairRequest| { &mut m.pair_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPairRequest>(
            "QueryPairRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPairRequest {
    const NAME: &'static str = "QueryPairRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pair_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pair_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pair_id != 0 {
            os.write_uint64(1, self.pair_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPairRequest {
        QueryPairRequest::new()
    }

    fn clear(&mut self) {
        self.pair_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPairRequest {
        static instance: QueryPairRequest = QueryPairRequest {
            pair_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPairRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPairRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPairRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPairRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryPairResponse is response type for the Query/Pair RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryPairResponse)
pub struct QueryPairResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryPairResponse.pair)
    pub pair: ::protobuf::MessageField<super::liquidity::Pair>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryPairResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryPairResponse {
    fn default() -> &'a QueryPairResponse {
        <QueryPairResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPairResponse {
    pub fn new() -> QueryPairResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::liquidity::Pair>(
            "pair",
            |m: &QueryPairResponse| { &m.pair },
            |m: &mut QueryPairResponse| { &mut m.pair },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryPairResponse>(
            "QueryPairResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryPairResponse {
    const NAME: &'static str = "QueryPairResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pair)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pair.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pair.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryPairResponse {
        QueryPairResponse::new()
    }

    fn clear(&mut self) {
        self.pair.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryPairResponse {
        static instance: QueryPairResponse = QueryPairResponse {
            pair: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryPairResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryPairResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryPairResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPairResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDepositRequestsRequest is request type for the Query/DepositRequests RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryDepositRequestsRequest)
pub struct QueryDepositRequestsRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestsRequest.pool_id)
    pub pool_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryDepositRequestsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDepositRequestsRequest {
    fn default() -> &'a QueryDepositRequestsRequest {
        <QueryDepositRequestsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDepositRequestsRequest {
    pub fn new() -> QueryDepositRequestsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &QueryDepositRequestsRequest| { &m.pool_id },
            |m: &mut QueryDepositRequestsRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryDepositRequestsRequest| { &m.pagination },
            |m: &mut QueryDepositRequestsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDepositRequestsRequest>(
            "QueryDepositRequestsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDepositRequestsRequest {
    const NAME: &'static str = "QueryDepositRequestsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pool_id = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pool_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pool_id != 0 {
            os.write_uint64(1, self.pool_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDepositRequestsRequest {
        QueryDepositRequestsRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDepositRequestsRequest {
        static instance: QueryDepositRequestsRequest = QueryDepositRequestsRequest {
            pool_id: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDepositRequestsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDepositRequestsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDepositRequestsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDepositRequestsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDepositRequestsResponse is response type for the Query/DepositRequests RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryDepositRequestsResponse)
pub struct QueryDepositRequestsResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestsResponse.deposit_requests)
    pub deposit_requests: ::std::vec::Vec<super::liquidity::DepositRequest>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryDepositRequestsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDepositRequestsResponse {
    fn default() -> &'a QueryDepositRequestsResponse {
        <QueryDepositRequestsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDepositRequestsResponse {
    pub fn new() -> QueryDepositRequestsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deposit_requests",
            |m: &QueryDepositRequestsResponse| { &m.deposit_requests },
            |m: &mut QueryDepositRequestsResponse| { &mut m.deposit_requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryDepositRequestsResponse| { &m.pagination },
            |m: &mut QueryDepositRequestsResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDepositRequestsResponse>(
            "QueryDepositRequestsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDepositRequestsResponse {
    const NAME: &'static str = "QueryDepositRequestsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.deposit_requests.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.deposit_requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.deposit_requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDepositRequestsResponse {
        QueryDepositRequestsResponse::new()
    }

    fn clear(&mut self) {
        self.deposit_requests.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDepositRequestsResponse {
        static instance: QueryDepositRequestsResponse = QueryDepositRequestsResponse {
            deposit_requests: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDepositRequestsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDepositRequestsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDepositRequestsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDepositRequestsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDepositRequestRequest is request type for the Query/DepositRequest RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryDepositRequestRequest)
pub struct QueryDepositRequestRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestRequest.pool_id)
    pub pool_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestRequest.id)
    pub id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryDepositRequestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDepositRequestRequest {
    fn default() -> &'a QueryDepositRequestRequest {
        <QueryDepositRequestRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDepositRequestRequest {
    pub fn new() -> QueryDepositRequestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &QueryDepositRequestRequest| { &m.pool_id },
            |m: &mut QueryDepositRequestRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &QueryDepositRequestRequest| { &m.id },
            |m: &mut QueryDepositRequestRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDepositRequestRequest>(
            "QueryDepositRequestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDepositRequestRequest {
    const NAME: &'static str = "QueryDepositRequestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pool_id = is.read_uint64()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pool_id);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pool_id != 0 {
            os.write_uint64(1, self.pool_id)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDepositRequestRequest {
        QueryDepositRequestRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id = 0;
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDepositRequestRequest {
        static instance: QueryDepositRequestRequest = QueryDepositRequestRequest {
            pool_id: 0,
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDepositRequestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDepositRequestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDepositRequestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDepositRequestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryDepositRequestResponse is response type for the Query/DepositRequest RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryDepositRequestResponse)
pub struct QueryDepositRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryDepositRequestResponse.deposit_request)
    pub deposit_request: ::protobuf::MessageField<super::liquidity::DepositRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryDepositRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryDepositRequestResponse {
    fn default() -> &'a QueryDepositRequestResponse {
        <QueryDepositRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDepositRequestResponse {
    pub fn new() -> QueryDepositRequestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::liquidity::DepositRequest>(
            "deposit_request",
            |m: &QueryDepositRequestResponse| { &m.deposit_request },
            |m: &mut QueryDepositRequestResponse| { &mut m.deposit_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryDepositRequestResponse>(
            "QueryDepositRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryDepositRequestResponse {
    const NAME: &'static str = "QueryDepositRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deposit_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deposit_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deposit_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryDepositRequestResponse {
        QueryDepositRequestResponse::new()
    }

    fn clear(&mut self) {
        self.deposit_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryDepositRequestResponse {
        static instance: QueryDepositRequestResponse = QueryDepositRequestResponse {
            deposit_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryDepositRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryDepositRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryDepositRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDepositRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryWithdrawRequestsRequest is request type for the Query/WithdrawRequests RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryWithdrawRequestsRequest)
pub struct QueryWithdrawRequestsRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestsRequest.pool_id)
    pub pool_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestsRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryWithdrawRequestsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryWithdrawRequestsRequest {
    fn default() -> &'a QueryWithdrawRequestsRequest {
        <QueryWithdrawRequestsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryWithdrawRequestsRequest {
    pub fn new() -> QueryWithdrawRequestsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &QueryWithdrawRequestsRequest| { &m.pool_id },
            |m: &mut QueryWithdrawRequestsRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryWithdrawRequestsRequest| { &m.pagination },
            |m: &mut QueryWithdrawRequestsRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryWithdrawRequestsRequest>(
            "QueryWithdrawRequestsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryWithdrawRequestsRequest {
    const NAME: &'static str = "QueryWithdrawRequestsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pool_id = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pool_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pool_id != 0 {
            os.write_uint64(1, self.pool_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryWithdrawRequestsRequest {
        QueryWithdrawRequestsRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryWithdrawRequestsRequest {
        static instance: QueryWithdrawRequestsRequest = QueryWithdrawRequestsRequest {
            pool_id: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryWithdrawRequestsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryWithdrawRequestsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryWithdrawRequestsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWithdrawRequestsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryWithdrawRequestsResponse is response type for the Query/WithdrawRequests RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryWithdrawRequestsResponse)
pub struct QueryWithdrawRequestsResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestsResponse.withdraw_requests)
    pub withdraw_requests: ::std::vec::Vec<super::liquidity::WithdrawRequest>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestsResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryWithdrawRequestsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryWithdrawRequestsResponse {
    fn default() -> &'a QueryWithdrawRequestsResponse {
        <QueryWithdrawRequestsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryWithdrawRequestsResponse {
    pub fn new() -> QueryWithdrawRequestsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "withdraw_requests",
            |m: &QueryWithdrawRequestsResponse| { &m.withdraw_requests },
            |m: &mut QueryWithdrawRequestsResponse| { &mut m.withdraw_requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryWithdrawRequestsResponse| { &m.pagination },
            |m: &mut QueryWithdrawRequestsResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryWithdrawRequestsResponse>(
            "QueryWithdrawRequestsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryWithdrawRequestsResponse {
    const NAME: &'static str = "QueryWithdrawRequestsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.withdraw_requests.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.withdraw_requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.withdraw_requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryWithdrawRequestsResponse {
        QueryWithdrawRequestsResponse::new()
    }

    fn clear(&mut self) {
        self.withdraw_requests.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryWithdrawRequestsResponse {
        static instance: QueryWithdrawRequestsResponse = QueryWithdrawRequestsResponse {
            withdraw_requests: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryWithdrawRequestsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryWithdrawRequestsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryWithdrawRequestsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWithdrawRequestsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryWithdrawRequestRequest is request type for the Query/WithdrawRequest RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryWithdrawRequestRequest)
pub struct QueryWithdrawRequestRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestRequest.pool_id)
    pub pool_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestRequest.id)
    pub id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryWithdrawRequestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryWithdrawRequestRequest {
    fn default() -> &'a QueryWithdrawRequestRequest {
        <QueryWithdrawRequestRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryWithdrawRequestRequest {
    pub fn new() -> QueryWithdrawRequestRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &QueryWithdrawRequestRequest| { &m.pool_id },
            |m: &mut QueryWithdrawRequestRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &QueryWithdrawRequestRequest| { &m.id },
            |m: &mut QueryWithdrawRequestRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryWithdrawRequestRequest>(
            "QueryWithdrawRequestRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryWithdrawRequestRequest {
    const NAME: &'static str = "QueryWithdrawRequestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pool_id = is.read_uint64()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pool_id);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pool_id != 0 {
            os.write_uint64(1, self.pool_id)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryWithdrawRequestRequest {
        QueryWithdrawRequestRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id = 0;
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryWithdrawRequestRequest {
        static instance: QueryWithdrawRequestRequest = QueryWithdrawRequestRequest {
            pool_id: 0,
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryWithdrawRequestRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryWithdrawRequestRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryWithdrawRequestRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWithdrawRequestRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryWithdrawRequestResponse is response type for the Query/WithdrawRequest RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryWithdrawRequestResponse)
pub struct QueryWithdrawRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryWithdrawRequestResponse.withdraw_request)
    pub withdraw_request: ::protobuf::MessageField<super::liquidity::WithdrawRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryWithdrawRequestResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryWithdrawRequestResponse {
    fn default() -> &'a QueryWithdrawRequestResponse {
        <QueryWithdrawRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryWithdrawRequestResponse {
    pub fn new() -> QueryWithdrawRequestResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::liquidity::WithdrawRequest>(
            "withdraw_request",
            |m: &QueryWithdrawRequestResponse| { &m.withdraw_request },
            |m: &mut QueryWithdrawRequestResponse| { &mut m.withdraw_request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryWithdrawRequestResponse>(
            "QueryWithdrawRequestResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryWithdrawRequestResponse {
    const NAME: &'static str = "QueryWithdrawRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.withdraw_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.withdraw_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.withdraw_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryWithdrawRequestResponse {
        QueryWithdrawRequestResponse::new()
    }

    fn clear(&mut self) {
        self.withdraw_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryWithdrawRequestResponse {
        static instance: QueryWithdrawRequestResponse = QueryWithdrawRequestResponse {
            withdraw_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryWithdrawRequestResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryWithdrawRequestResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryWithdrawRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWithdrawRequestResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrdersRequest is request type for the Query/Orders RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrdersRequest)
pub struct QueryOrdersRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersRequest.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrdersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrdersRequest {
    fn default() -> &'a QueryOrdersRequest {
        <QueryOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrdersRequest {
    pub fn new() -> QueryOrdersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &QueryOrdersRequest| { &m.pair_id },
            |m: &mut QueryOrdersRequest| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryOrdersRequest| { &m.pagination },
            |m: &mut QueryOrdersRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrdersRequest>(
            "QueryOrdersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrdersRequest {
    const NAME: &'static str = "QueryOrdersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pair_id = is.read_uint64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pair_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pair_id != 0 {
            os.write_uint64(1, self.pair_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrdersRequest {
        QueryOrdersRequest::new()
    }

    fn clear(&mut self) {
        self.pair_id = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrdersRequest {
        static instance: QueryOrdersRequest = QueryOrdersRequest {
            pair_id: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrdersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrdersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrdersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrdersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrdersResponse is response type for the Query/Orders RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrdersResponse)
pub struct QueryOrdersResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersResponse.orders)
    pub orders: ::std::vec::Vec<super::liquidity::Order>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersResponse.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrdersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrdersResponse {
    fn default() -> &'a QueryOrdersResponse {
        <QueryOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrdersResponse {
    pub fn new() -> QueryOrdersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orders",
            |m: &QueryOrdersResponse| { &m.orders },
            |m: &mut QueryOrdersResponse| { &mut m.orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageResponse>(
            "pagination",
            |m: &QueryOrdersResponse| { &m.pagination },
            |m: &mut QueryOrdersResponse| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrdersResponse>(
            "QueryOrdersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrdersResponse {
    const NAME: &'static str = "QueryOrdersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orders.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.orders {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrdersResponse {
        QueryOrdersResponse::new()
    }

    fn clear(&mut self) {
        self.orders.clear();
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrdersResponse {
        static instance: QueryOrdersResponse = QueryOrdersResponse {
            orders: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrdersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrdersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrdersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrdersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrderRequest is request type for the Query/Order RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrderRequest)
pub struct QueryOrderRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderRequest.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderRequest.id)
    pub id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrderRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrderRequest {
    fn default() -> &'a QueryOrderRequest {
        <QueryOrderRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrderRequest {
    pub fn new() -> QueryOrderRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &QueryOrderRequest| { &m.pair_id },
            |m: &mut QueryOrderRequest| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &QueryOrderRequest| { &m.id },
            |m: &mut QueryOrderRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrderRequest>(
            "QueryOrderRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrderRequest {
    const NAME: &'static str = "QueryOrderRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pair_id = is.read_uint64()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pair_id);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pair_id != 0 {
            os.write_uint64(1, self.pair_id)?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrderRequest {
        QueryOrderRequest::new()
    }

    fn clear(&mut self) {
        self.pair_id = 0;
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrderRequest {
        static instance: QueryOrderRequest = QueryOrderRequest {
            pair_id: 0,
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrderRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrderRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrderRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrderResponse is response type for the Query/Order RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrderResponse)
pub struct QueryOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderResponse.order)
    pub order: ::protobuf::MessageField<super::liquidity::Order>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrderResponse {
    fn default() -> &'a QueryOrderResponse {
        <QueryOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrderResponse {
    pub fn new() -> QueryOrderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::liquidity::Order>(
            "order",
            |m: &QueryOrderResponse| { &m.order },
            |m: &mut QueryOrderResponse| { &mut m.order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrderResponse>(
            "QueryOrderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrderResponse {
    const NAME: &'static str = "QueryOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrderResponse {
        QueryOrderResponse::new()
    }

    fn clear(&mut self) {
        self.order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrderResponse {
        static instance: QueryOrderResponse = QueryOrderResponse {
            order: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrdersByOrdererRequest is request type for the Query/OrdersByOrderer RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrdersByOrdererRequest)
pub struct QueryOrdersByOrdererRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersByOrdererRequest.orderer)
    pub orderer: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersByOrdererRequest.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrdersByOrdererRequest.pagination)
    pub pagination: ::protobuf::MessageField<super::pagination::PageRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrdersByOrdererRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrdersByOrdererRequest {
    fn default() -> &'a QueryOrdersByOrdererRequest {
        <QueryOrdersByOrdererRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrdersByOrdererRequest {
    pub fn new() -> QueryOrdersByOrdererRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orderer",
            |m: &QueryOrdersByOrdererRequest| { &m.orderer },
            |m: &mut QueryOrdersByOrdererRequest| { &mut m.orderer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &QueryOrdersByOrdererRequest| { &m.pair_id },
            |m: &mut QueryOrdersByOrdererRequest| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::pagination::PageRequest>(
            "pagination",
            |m: &QueryOrdersByOrdererRequest| { &m.pagination },
            |m: &mut QueryOrdersByOrdererRequest| { &mut m.pagination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrdersByOrdererRequest>(
            "QueryOrdersByOrdererRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrdersByOrdererRequest {
    const NAME: &'static str = "QueryOrdersByOrdererRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orderer = is.read_string()?;
                },
                16 => {
                    self.pair_id = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.orderer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.orderer);
        }
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.pair_id);
        }
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.orderer.is_empty() {
            os.write_string(1, &self.orderer)?;
        }
        if self.pair_id != 0 {
            os.write_uint64(2, self.pair_id)?;
        }
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrdersByOrdererRequest {
        QueryOrdersByOrdererRequest::new()
    }

    fn clear(&mut self) {
        self.orderer.clear();
        self.pair_id = 0;
        self.pagination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrdersByOrdererRequest {
        static instance: QueryOrdersByOrdererRequest = QueryOrdersByOrdererRequest {
            orderer: ::std::string::String::new(),
            pair_id: 0,
            pagination: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrdersByOrdererRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrdersByOrdererRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrdersByOrdererRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrdersByOrdererRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrderBooksRequest is request type for the Query/OrderBooks RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrderBooksRequest)
pub struct QueryOrderBooksRequest {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderBooksRequest.pair_ids)
    pub pair_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderBooksRequest.price_unit_powers)
    pub price_unit_powers: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderBooksRequest.num_ticks)
    pub num_ticks: u32,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrderBooksRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrderBooksRequest {
    fn default() -> &'a QueryOrderBooksRequest {
        <QueryOrderBooksRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrderBooksRequest {
    pub fn new() -> QueryOrderBooksRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pair_ids",
            |m: &QueryOrderBooksRequest| { &m.pair_ids },
            |m: &mut QueryOrderBooksRequest| { &mut m.pair_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "price_unit_powers",
            |m: &QueryOrderBooksRequest| { &m.price_unit_powers },
            |m: &mut QueryOrderBooksRequest| { &mut m.price_unit_powers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_ticks",
            |m: &QueryOrderBooksRequest| { &m.num_ticks },
            |m: &mut QueryOrderBooksRequest| { &mut m.num_ticks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrderBooksRequest>(
            "QueryOrderBooksRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrderBooksRequest {
    const NAME: &'static str = "QueryOrderBooksRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.pair_ids)?;
                },
                8 => {
                    self.pair_ids.push(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.price_unit_powers)?;
                },
                16 => {
                    self.price_unit_powers.push(is.read_uint32()?);
                },
                24 => {
                    self.num_ticks = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pair_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        for value in &self.price_unit_powers {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if self.num_ticks != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.num_ticks);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pair_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.price_unit_powers {
            os.write_uint32(2, *v)?;
        };
        if self.num_ticks != 0 {
            os.write_uint32(3, self.num_ticks)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrderBooksRequest {
        QueryOrderBooksRequest::new()
    }

    fn clear(&mut self) {
        self.pair_ids.clear();
        self.price_unit_powers.clear();
        self.num_ticks = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrderBooksRequest {
        static instance: QueryOrderBooksRequest = QueryOrderBooksRequest {
            pair_ids: ::std::vec::Vec::new(),
            price_unit_powers: ::std::vec::Vec::new(),
            num_ticks: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrderBooksRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrderBooksRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrderBooksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrderBooksRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  QueryOrderBooksResponse is response type for Query/OrderBooks RPC method.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.QueryOrderBooksResponse)
pub struct QueryOrderBooksResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.QueryOrderBooksResponse.pairs)
    pub pairs: ::std::vec::Vec<OrderBookPairResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.QueryOrderBooksResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryOrderBooksResponse {
    fn default() -> &'a QueryOrderBooksResponse {
        <QueryOrderBooksResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOrderBooksResponse {
    pub fn new() -> QueryOrderBooksResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pairs",
            |m: &QueryOrderBooksResponse| { &m.pairs },
            |m: &mut QueryOrderBooksResponse| { &mut m.pairs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryOrderBooksResponse>(
            "QueryOrderBooksResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryOrderBooksResponse {
    const NAME: &'static str = "QueryOrderBooksResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.pairs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pairs {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryOrderBooksResponse {
        QueryOrderBooksResponse::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryOrderBooksResponse {
        static instance: QueryOrderBooksResponse = QueryOrderBooksResponse {
            pairs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryOrderBooksResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryOrderBooksResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryOrderBooksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOrderBooksResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PoolResponse defines a custom pool response message.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.PoolResponse)
pub struct PoolResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.type)
    pub type_: ::protobuf::EnumOrUnknown<super::liquidity::PoolType>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.id)
    pub id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.reserve_address)
    pub reserve_address: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.pool_coin_denom)
    pub pool_coin_denom: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.pool_coin_supply)
    pub pool_coin_supply: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.min_price)
    pub min_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.max_price)
    pub max_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.balances)
    pub balances: ::protobuf::MessageField<PoolBalances>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.last_deposit_request_id)
    pub last_deposit_request_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.last_withdraw_request_id)
    pub last_withdraw_request_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolResponse.disabled)
    pub disabled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.PoolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolResponse {
    fn default() -> &'a PoolResponse {
        <PoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoolResponse {
    pub fn new() -> PoolResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &PoolResponse| { &m.type_ },
            |m: &mut PoolResponse| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PoolResponse| { &m.id },
            |m: &mut PoolResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &PoolResponse| { &m.pair_id },
            |m: &mut PoolResponse| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &PoolResponse| { &m.creator },
            |m: &mut PoolResponse| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reserve_address",
            |m: &PoolResponse| { &m.reserve_address },
            |m: &mut PoolResponse| { &mut m.reserve_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_coin_denom",
            |m: &PoolResponse| { &m.pool_coin_denom },
            |m: &mut PoolResponse| { &mut m.pool_coin_denom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_coin_supply",
            |m: &PoolResponse| { &m.pool_coin_supply },
            |m: &mut PoolResponse| { &mut m.pool_coin_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_price",
            |m: &PoolResponse| { &m.min_price },
            |m: &mut PoolResponse| { &mut m.min_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_price",
            |m: &PoolResponse| { &m.max_price },
            |m: &mut PoolResponse| { &mut m.max_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &PoolResponse| { &m.price },
            |m: &mut PoolResponse| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolBalances>(
            "balances",
            |m: &PoolResponse| { &m.balances },
            |m: &mut PoolResponse| { &mut m.balances },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_deposit_request_id",
            |m: &PoolResponse| { &m.last_deposit_request_id },
            |m: &mut PoolResponse| { &mut m.last_deposit_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_withdraw_request_id",
            |m: &PoolResponse| { &m.last_withdraw_request_id },
            |m: &mut PoolResponse| { &mut m.last_withdraw_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled",
            |m: &PoolResponse| { &m.disabled },
            |m: &mut PoolResponse| { &mut m.disabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolResponse>(
            "PoolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolResponse {
    const NAME: &'static str = "PoolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                24 => {
                    self.pair_id = is.read_uint64()?;
                },
                34 => {
                    self.creator = is.read_string()?;
                },
                42 => {
                    self.reserve_address = is.read_string()?;
                },
                50 => {
                    self.pool_coin_denom = is.read_string()?;
                },
                58 => {
                    self.pool_coin_supply = is.read_string()?;
                },
                66 => {
                    self.min_price = is.read_string()?;
                },
                74 => {
                    self.max_price = is.read_string()?;
                },
                82 => {
                    self.price = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balances)?;
                },
                96 => {
                    self.last_deposit_request_id = is.read_uint64()?;
                },
                104 => {
                    self.last_withdraw_request_id = is.read_uint64()?;
                },
                112 => {
                    self.disabled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::liquidity::PoolType::POOL_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.pair_id);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.creator);
        }
        if !self.reserve_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.reserve_address);
        }
        if !self.pool_coin_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.pool_coin_denom);
        }
        if !self.pool_coin_supply.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.pool_coin_supply);
        }
        if !self.min_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.min_price);
        }
        if !self.max_price.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.max_price);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.price);
        }
        if let Some(v) = self.balances.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.last_deposit_request_id != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.last_deposit_request_id);
        }
        if self.last_withdraw_request_id != 0 {
            my_size += ::protobuf::rt::uint64_size(13, self.last_withdraw_request_id);
        }
        if self.disabled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::liquidity::PoolType::POOL_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if self.pair_id != 0 {
            os.write_uint64(3, self.pair_id)?;
        }
        if !self.creator.is_empty() {
            os.write_string(4, &self.creator)?;
        }
        if !self.reserve_address.is_empty() {
            os.write_string(5, &self.reserve_address)?;
        }
        if !self.pool_coin_denom.is_empty() {
            os.write_string(6, &self.pool_coin_denom)?;
        }
        if !self.pool_coin_supply.is_empty() {
            os.write_string(7, &self.pool_coin_supply)?;
        }
        if !self.min_price.is_empty() {
            os.write_string(8, &self.min_price)?;
        }
        if !self.max_price.is_empty() {
            os.write_string(9, &self.max_price)?;
        }
        if !self.price.is_empty() {
            os.write_string(10, &self.price)?;
        }
        if let Some(v) = self.balances.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if self.last_deposit_request_id != 0 {
            os.write_uint64(12, self.last_deposit_request_id)?;
        }
        if self.last_withdraw_request_id != 0 {
            os.write_uint64(13, self.last_withdraw_request_id)?;
        }
        if self.disabled != false {
            os.write_bool(14, self.disabled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolResponse {
        PoolResponse::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(super::liquidity::PoolType::POOL_TYPE_UNSPECIFIED);
        self.id = 0;
        self.pair_id = 0;
        self.creator.clear();
        self.reserve_address.clear();
        self.pool_coin_denom.clear();
        self.pool_coin_supply.clear();
        self.min_price.clear();
        self.max_price.clear();
        self.price.clear();
        self.balances.clear();
        self.last_deposit_request_id = 0;
        self.last_withdraw_request_id = 0;
        self.disabled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolResponse {
        static instance: PoolResponse = PoolResponse {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: 0,
            pair_id: 0,
            creator: ::std::string::String::new(),
            reserve_address: ::std::string::String::new(),
            pool_coin_denom: ::std::string::String::new(),
            pool_coin_supply: ::std::string::String::new(),
            min_price: ::std::string::String::new(),
            max_price: ::std::string::String::new(),
            price: ::std::string::String::new(),
            balances: ::protobuf::MessageField::none(),
            last_deposit_request_id: 0,
            last_withdraw_request_id: 0,
            disabled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.PoolBalances)
pub struct PoolBalances {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolBalances.base_coin)
    pub base_coin: ::protobuf::MessageField<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.PoolBalances.quote_coin)
    pub quote_coin: ::protobuf::MessageField<super::coin::Coin>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.PoolBalances.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolBalances {
    fn default() -> &'a PoolBalances {
        <PoolBalances as ::protobuf::Message>::default_instance()
    }
}

impl PoolBalances {
    pub fn new() -> PoolBalances {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "base_coin",
            |m: &PoolBalances| { &m.base_coin },
            |m: &mut PoolBalances| { &mut m.base_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "quote_coin",
            |m: &PoolBalances| { &m.quote_coin },
            |m: &mut PoolBalances| { &mut m.quote_coin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolBalances>(
            "PoolBalances",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolBalances {
    const NAME: &'static str = "PoolBalances";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_coin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quote_coin)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quote_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quote_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolBalances {
        PoolBalances::new()
    }

    fn clear(&mut self) {
        self.base_coin.clear();
        self.quote_coin.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolBalances {
        static instance: PoolBalances = PoolBalances {
            base_coin: ::protobuf::MessageField::none(),
            quote_coin: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolBalances {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolBalances").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolBalances {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolBalances {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.OrderBookPairResponse)
pub struct OrderBookPairResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookPairResponse.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookPairResponse.base_price)
    pub base_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookPairResponse.order_books)
    pub order_books: ::std::vec::Vec<OrderBookResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.OrderBookPairResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderBookPairResponse {
    fn default() -> &'a OrderBookPairResponse {
        <OrderBookPairResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderBookPairResponse {
    pub fn new() -> OrderBookPairResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &OrderBookPairResponse| { &m.pair_id },
            |m: &mut OrderBookPairResponse| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base_price",
            |m: &OrderBookPairResponse| { &m.base_price },
            |m: &mut OrderBookPairResponse| { &mut m.base_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "order_books",
            |m: &OrderBookPairResponse| { &m.order_books },
            |m: &mut OrderBookPairResponse| { &mut m.order_books },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderBookPairResponse>(
            "OrderBookPairResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderBookPairResponse {
    const NAME: &'static str = "OrderBookPairResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pair_id = is.read_uint64()?;
                },
                18 => {
                    self.base_price = is.read_string()?;
                },
                26 => {
                    self.order_books.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.pair_id);
        }
        if !self.base_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_price);
        }
        for value in &self.order_books {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pair_id != 0 {
            os.write_uint64(1, self.pair_id)?;
        }
        if !self.base_price.is_empty() {
            os.write_string(2, &self.base_price)?;
        }
        for v in &self.order_books {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderBookPairResponse {
        OrderBookPairResponse::new()
    }

    fn clear(&mut self) {
        self.pair_id = 0;
        self.base_price.clear();
        self.order_books.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderBookPairResponse {
        static instance: OrderBookPairResponse = OrderBookPairResponse {
            pair_id: 0,
            base_price: ::std::string::String::new(),
            order_books: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderBookPairResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderBookPairResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderBookPairResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderBookPairResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.OrderBookResponse)
pub struct OrderBookResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookResponse.price_unit)
    pub price_unit: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookResponse.sells)
    pub sells: ::std::vec::Vec<OrderBookTickResponse>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookResponse.buys)
    pub buys: ::std::vec::Vec<OrderBookTickResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.OrderBookResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderBookResponse {
    fn default() -> &'a OrderBookResponse {
        <OrderBookResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderBookResponse {
    pub fn new() -> OrderBookResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price_unit",
            |m: &OrderBookResponse| { &m.price_unit },
            |m: &mut OrderBookResponse| { &mut m.price_unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sells",
            |m: &OrderBookResponse| { &m.sells },
            |m: &mut OrderBookResponse| { &mut m.sells },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buys",
            |m: &OrderBookResponse| { &m.buys },
            |m: &mut OrderBookResponse| { &mut m.buys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderBookResponse>(
            "OrderBookResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderBookResponse {
    const NAME: &'static str = "OrderBookResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.price_unit = is.read_string()?;
                },
                18 => {
                    self.sells.push(is.read_message()?);
                },
                26 => {
                    self.buys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.price_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price_unit);
        }
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.price_unit.is_empty() {
            os.write_string(1, &self.price_unit)?;
        }
        for v in &self.sells {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.buys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderBookResponse {
        OrderBookResponse::new()
    }

    fn clear(&mut self) {
        self.price_unit.clear();
        self.sells.clear();
        self.buys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderBookResponse {
        static instance: OrderBookResponse = OrderBookResponse {
            price_unit: ::std::string::String::new(),
            sells: ::std::vec::Vec::new(),
            buys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderBookResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderBookResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderBookResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderBookResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.OrderBookTickResponse)
pub struct OrderBookTickResponse {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookTickResponse.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookTickResponse.user_order_amount)
    pub user_order_amount: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.OrderBookTickResponse.pool_order_amount)
    pub pool_order_amount: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.OrderBookTickResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderBookTickResponse {
    fn default() -> &'a OrderBookTickResponse {
        <OrderBookTickResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderBookTickResponse {
    pub fn new() -> OrderBookTickResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &OrderBookTickResponse| { &m.price },
            |m: &mut OrderBookTickResponse| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_order_amount",
            |m: &OrderBookTickResponse| { &m.user_order_amount },
            |m: &mut OrderBookTickResponse| { &mut m.user_order_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_order_amount",
            |m: &OrderBookTickResponse| { &m.pool_order_amount },
            |m: &mut OrderBookTickResponse| { &mut m.pool_order_amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderBookTickResponse>(
            "OrderBookTickResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderBookTickResponse {
    const NAME: &'static str = "OrderBookTickResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.price = is.read_string()?;
                },
                18 => {
                    self.user_order_amount = is.read_string()?;
                },
                26 => {
                    self.pool_order_amount = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.user_order_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_order_amount);
        }
        if !self.pool_order_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.pool_order_amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.user_order_amount.is_empty() {
            os.write_string(2, &self.user_order_amount)?;
        }
        if !self.pool_order_amount.is_empty() {
            os.write_string(3, &self.pool_order_amount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderBookTickResponse {
        OrderBookTickResponse::new()
    }

    fn clear(&mut self) {
        self.price.clear();
        self.user_order_amount.clear();
        self.pool_order_amount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderBookTickResponse {
        static instance: OrderBookTickResponse = OrderBookTickResponse {
            price: ::std::string::String::new(),
            user_order_amount: ::std::string::String::new(),
            pool_order_amount: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderBookTickResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderBookTickResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderBookTickResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderBookTickResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bquery.proto\x12\x13shogun.liquidity.v1\x1a\x1ecosmos/base/v1beta1/\
    coin.proto\x1a*cosmos/base/query/v1beta1/pagination.proto\x1a\x0fliquidi\
    ty.proto\"\x14\n\x12QueryParamsRequest\"J\n\x13QueryParamsResponse\x123\
    \n\x06params\x18\x01\x20\x01(\x0b2\x1b.shogun.liquidity.v1.ParamsR\x06pa\
    rams\"\x90\x01\n\x11QueryPoolsRequest\x12\x17\n\x07pair_id\x18\x01\x20\
    \x01(\x04R\x06pairId\x12\x1a\n\x08disabled\x18\x02\x20\x01(\tR\x08disabl\
    ed\x12F\n\npagination\x18\x03\x20\x01(\x0b2&.cosmos.base.query.v1beta1.P\
    ageRequestR\npagination\"\x96\x01\n\x12QueryPoolsResponse\x127\n\x05pool\
    s\x18\x01\x20\x03(\x0b2!.shogun.liquidity.v1.PoolResponseR\x05pools\x12G\
    \n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResp\
    onseR\npagination\"+\n\x10QueryPoolRequest\x12\x17\n\x07pool_id\x18\x01\
    \x20\x01(\x04R\x06poolId\"J\n\x11QueryPoolResponse\x125\n\x04pool\x18\
    \x01\x20\x01(\x0b2!.shogun.liquidity.v1.PoolResponseR\x04pool\"K\n\x20Qu\
    eryPoolByReserveAddressRequest\x12'\n\x0freserve_address\x18\x01\x20\x01\
    (\tR\x0ereserveAddress\"I\n\x1fQueryPoolByPoolCoinDenomRequest\x12&\n\
    \x0fpool_coin_denom\x18\x01\x20\x01(\tR\rpoolCoinDenom\"s\n\x11QueryPair\
    sRequest\x12\x16\n\x06denoms\x18\x01\x20\x03(\tR\x06denoms\x12F\n\npagin\
    ation\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npag\
    ination\"\x8e\x01\n\x12QueryPairsResponse\x12/\n\x05pairs\x18\x01\x20\
    \x03(\x0b2\x19.shogun.liquidity.v1.PairR\x05pairs\x12G\n\npagination\x18\
    \x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1.PageResponseR\npagination\
    \"+\n\x10QueryPairRequest\x12\x17\n\x07pair_id\x18\x01\x20\x01(\x04R\x06\
    pairId\"B\n\x11QueryPairResponse\x12-\n\x04pair\x18\x01\x20\x01(\x0b2\
    \x19.shogun.liquidity.v1.PairR\x04pair\"~\n\x1bQueryDepositRequestsReque\
    st\x12\x17\n\x07pool_id\x18\x01\x20\x01(\x04R\x06poolId\x12F\n\npaginati\
    on\x18\x02\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagina\
    tion\"\xb7\x01\n\x1cQueryDepositRequestsResponse\x12N\n\x10deposit_reque\
    sts\x18\x01\x20\x03(\x0b2#.shogun.liquidity.v1.DepositRequestR\x0fdeposi\
    tRequests\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1\
    beta1.PageResponseR\npagination\"E\n\x1aQueryDepositRequestRequest\x12\
    \x17\n\x07pool_id\x18\x01\x20\x01(\x04R\x06poolId\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\x04R\x02id\"k\n\x1bQueryDepositRequestResponse\x12L\n\x0fd\
    eposit_request\x18\x01\x20\x01(\x0b2#.shogun.liquidity.v1.DepositRequest\
    R\x0edepositRequest\"\x7f\n\x1cQueryWithdrawRequestsRequest\x12\x17\n\
    \x07pool_id\x18\x01\x20\x01(\x04R\x06poolId\x12F\n\npagination\x18\x02\
    \x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npagination\"\xbb\
    \x01\n\x1dQueryWithdrawRequestsResponse\x12Q\n\x11withdraw_requests\x18\
    \x01\x20\x03(\x0b2$.shogun.liquidity.v1.WithdrawRequestR\x10withdrawRequ\
    ests\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.query.v1beta1\
    .PageResponseR\npagination\"F\n\x1bQueryWithdrawRequestRequest\x12\x17\n\
    \x07pool_id\x18\x01\x20\x01(\x04R\x06poolId\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\x04R\x02id\"o\n\x1cQueryWithdrawRequestResponse\x12O\n\x10withdraw\
    _request\x18\x01\x20\x01(\x0b2$.shogun.liquidity.v1.WithdrawRequestR\x0f\
    withdrawRequest\"u\n\x12QueryOrdersRequest\x12\x17\n\x07pair_id\x18\x01\
    \x20\x01(\x04R\x06pairId\x12F\n\npagination\x18\x02\x20\x01(\x0b2&.cosmo\
    s.base.query.v1beta1.PageRequestR\npagination\"\x92\x01\n\x13QueryOrders\
    Response\x122\n\x06orders\x18\x01\x20\x03(\x0b2\x1a.shogun.liquidity.v1.\
    OrderR\x06orders\x12G\n\npagination\x18\x02\x20\x01(\x0b2'.cosmos.base.q\
    uery.v1beta1.PageResponseR\npagination\"<\n\x11QueryOrderRequest\x12\x17\
    \n\x07pair_id\x18\x01\x20\x01(\x04R\x06pairId\x12\x0e\n\x02id\x18\x02\
    \x20\x01(\x04R\x02id\"F\n\x12QueryOrderResponse\x120\n\x05order\x18\x01\
    \x20\x01(\x0b2\x1a.shogun.liquidity.v1.OrderR\x05order\"\x98\x01\n\x1bQu\
    eryOrdersByOrdererRequest\x12\x18\n\x07orderer\x18\x01\x20\x01(\tR\x07or\
    derer\x12\x17\n\x07pair_id\x18\x02\x20\x01(\x04R\x06pairId\x12F\n\npagin\
    ation\x18\x03\x20\x01(\x0b2&.cosmos.base.query.v1beta1.PageRequestR\npag\
    ination\"|\n\x16QueryOrderBooksRequest\x12\x19\n\x08pair_ids\x18\x01\x20\
    \x03(\x04R\x07pairIds\x12*\n\x11price_unit_powers\x18\x02\x20\x03(\rR\
    \x0fpriceUnitPowers\x12\x1b\n\tnum_ticks\x18\x03\x20\x01(\rR\x08numTicks\
    \"[\n\x17QueryOrderBooksResponse\x12@\n\x05pairs\x18\x02\x20\x03(\x0b2*.\
    shogun.liquidity.v1.OrderBookPairResponseR\x05pairs\"\x9a\x04\n\x0cPoolR\
    esponse\x121\n\x04type\x18\x01\x20\x01(\x0e2\x1d.shogun.liquidity.v1.Poo\
    lTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\x12\x17\n\x07\
    pair_id\x18\x03\x20\x01(\x04R\x06pairId\x12\x18\n\x07creator\x18\x04\x20\
    \x01(\tR\x07creator\x12'\n\x0freserve_address\x18\x05\x20\x01(\tR\x0eres\
    erveAddress\x12&\n\x0fpool_coin_denom\x18\x06\x20\x01(\tR\rpoolCoinDenom\
    \x12(\n\x10pool_coin_supply\x18\x07\x20\x01(\tR\x0epoolCoinSupply\x12\
    \x1b\n\tmin_price\x18\x08\x20\x01(\tR\x08minPrice\x12\x1b\n\tmax_price\
    \x18\t\x20\x01(\tR\x08maxPrice\x12\x14\n\x05price\x18\n\x20\x01(\tR\x05p\
    rice\x12=\n\x08balances\x18\x0b\x20\x01(\x0b2!.shogun.liquidity.v1.PoolB\
    alancesR\x08balances\x125\n\x17last_deposit_request_id\x18\x0c\x20\x01(\
    \x04R\x14lastDepositRequestId\x127\n\x18last_withdraw_request_id\x18\r\
    \x20\x01(\x04R\x15lastWithdrawRequestId\x12\x1a\n\x08disabled\x18\x0e\
    \x20\x01(\x08R\x08disabled\"\x80\x01\n\x0cPoolBalances\x126\n\tbase_coin\
    \x18\x01\x20\x01(\x0b2\x19.cosmos.base.v1beta1.CoinR\x08baseCoin\x128\n\
    \nquote_coin\x18\x02\x20\x01(\x0b2\x19.cosmos.base.v1beta1.CoinR\tquoteC\
    oin\"\x98\x01\n\x15OrderBookPairResponse\x12\x17\n\x07pair_id\x18\x01\
    \x20\x01(\x04R\x06pairId\x12\x1d\n\nbase_price\x18\x02\x20\x01(\tR\tbase\
    Price\x12G\n\x0border_books\x18\x03\x20\x03(\x0b2&.shogun.liquidity.v1.O\
    rderBookResponseR\norderBooks\"\xb4\x01\n\x11OrderBookResponse\x12\x1d\n\
    \nprice_unit\x18\x01\x20\x01(\tR\tpriceUnit\x12@\n\x05sells\x18\x02\x20\
    \x03(\x0b2*.shogun.liquidity.v1.OrderBookTickResponseR\x05sells\x12>\n\
    \x04buys\x18\x03\x20\x03(\x0b2*.shogun.liquidity.v1.OrderBookTickRespons\
    eR\x04buys\"\x85\x01\n\x15OrderBookTickResponse\x12\x14\n\x05price\x18\
    \x01\x20\x01(\tR\x05price\x12*\n\x11user_order_amount\x18\x02\x20\x01(\t\
    R\x0fuserOrderAmount\x12*\n\x11pool_order_amount\x18\x03\x20\x01(\tR\x0f\
    poolOrderAmountJ\xa0R\n\x07\x12\x05\0\0\xb0\x02\x01\n\x08\n\x01\x0c\x12\
    \x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x1c\n\t\n\x02\x03\0\x12\x03\
    \x03\0(\n\t\n\x02\x03\x01\x12\x03\x04\04\n\t\n\x02\x03\x02\x12\x03\x05\0\
    \x19\n\xc5\x19\n\x02\x04\0\x12\x03V\0\x1d\x1aE\x20QueryParamsRequest\x20\
    is\x20request\x20type\x20for\x20the\x20Query/Params\x20RPC\x20method.\n2\
    )\x20Query\x20defines\x20the\x20gRPC\x20querier\x20service.\n2\xc7\x18se\
    rvice\x20Query\x20{\n//\x20Params\x20returns\x20parameters\x20of\x20the\
    \x20module.\nrpc\x20Params(QueryParamsRequest)\x20returns\x20(QueryParam\
    sResponse)\x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liqui\
    dity/v1beta1/params\";\n}\n\n//\x20Pools\x20returns\x20all\x20liquidity\
    \x20pools.\nrpc\x20Pools(QueryPoolsRequest)\x20returns\x20(QueryPoolsRes\
    ponse)\x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidity\
    /v1beta1/pools\";\n}\n\n//\x20Pool\x20returns\x20the\x20specific\x20liqu\
    idity\x20pool.\nrpc\x20Pool(QueryPoolRequest)\x20returns\x20(QueryPoolRe\
    sponse)\x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidit\
    y/v1beta1/pools/{pool_id}\";\n}\n\n//\x20PoolByReserveAddress\x20returns\
    \x20all\x20pools\x20that\x20correspond\x20to\x20the\x20reserve\x20accoun\
    t.\nrpc\x20PoolByReserveAddress(QueryPoolByReserveAddressRequest)\x20ret\
    urns\x20(QueryPoolResponse)\x20{\noption\x20(google.api.http).get\x20=\
    \x20\"/shogun/liquidity/v1beta1/pools/reserve_address/{reserve_address}\
    \";\n}\n\n//\x20PoolByPoolCoinDenom\x20returns\x20all\x20pools\x20that\
    \x20correspond\x20to\x20the\x20pool\x20coin\x20denom.\nrpc\x20PoolByPool\
    CoinDenom(QueryPoolByPoolCoinDenomRequest)\x20returns\x20(QueryPoolRespo\
    nse)\x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidity/v\
    1beta1/pools/pool_coin_denom/{pool_coin_denom}\";\n}\n\n//\x20Pairs\x20r\
    eturns\x20all\x20liquidity\x20pairs.\nrpc\x20Pairs(QueryPairsRequest)\
    \x20returns\x20(QueryPairsResponse)\x20{\noption\x20(google.api.http).ge\
    t\x20=\x20\"/shogun/liquidity/v1beta1/pairs\";\n}\n\n//\x20Pair\x20retur\
    ns\x20the\x20specific\x20pair.\nrpc\x20Pair(QueryPairRequest)\x20returns\
    \x20(QueryPairResponse)\x20{\noption\x20(google.api.http).get\x20=\x20\"\
    /shogun/liquidity/v1beta1/pairs/{pair_id}\";\n}\n\n//\x20DepositRequests\
    \x20returns\x20all\x20deposit\x20requests.\nrpc\x20DepositRequests(Query\
    DepositRequestsRequest)\x20returns\x20(QueryDepositRequestsResponse)\x20\
    {\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidity/v1beta1/p\
    ools/{pool_id}/deposit_requests\";\n}\n\n//\x20DepositRequest\x20returns\
    \x20the\x20specific\x20deposit\x20request.\nrpc\x20DepositRequest(QueryD\
    epositRequestRequest)\x20returns\x20(QueryDepositRequestResponse)\x20{\n\
    option\x20(google.api.http).get\x20=\x20\"/shogun/liquidity/v1beta1/pool\
    s/{pool_id}/deposit_requests/{id}\";\n}\n\n//\x20WithdrawRequests\x20ret\
    urns\x20all\x20withdraw\x20requests.\nrpc\x20WithdrawRequests(QueryWithd\
    rawRequestsRequest)\x20returns\x20(QueryWithdrawRequestsResponse)\x20{\n\
    option\x20(google.api.http).get\x20=\x20\"/shogun/liquidity/v1beta1/pool\
    s/{pool_id}/withdraw_requests\";\n}\n\n//\x20WithdrawRequest\x20returns\
    \x20the\x20specific\x20withdraw\x20request.\nrpc\x20WithdrawRequest(Quer\
    yWithdrawRequestRequest)\x20returns\x20(QueryWithdrawRequestResponse)\
    \x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidity/v1bet\
    a1/pools/{pool_id}/withdraw_requests/{id}\";\n}\n\n//\x20Orders\x20retur\
    ns\x20all\x20orders\x20within\x20the\x20pair.\nrpc\x20Orders(QueryOrders\
    Request)\x20returns\x20(QueryOrdersResponse)\x20{\noption\x20(google.api\
    .http).get\x20=\x20\"/shogun/liquidity/v1beta1/pairs/{pair_id}/orders\";\
    \n}\n\n//\x20Order\x20returns\x20the\x20specific\x20order.\nrpc\x20Order\
    (QueryOrderRequest)\x20returns\x20(QueryOrderResponse)\x20{\noption\x20(\
    google.api.http).get\x20=\x20\"/shogun/liquidity/v1beta1/pairs/{pair_id}\
    /orders/{id}\";\n}\n\n//\x20OrdersByOrderer\x20returns\x20orders\x20made\
    \x20by\x20an\x20orderer.\nrpc\x20OrdersByOrderer(QueryOrdersByOrdererReq\
    uest)\x20returns\x20(QueryOrdersResponse)\x20{\noption\x20(google.api.ht\
    tp).get\x20=\x20\"/shogun/liquidity/v1beta1/orders/{orderer}\";\n}\n\nrp\
    c\x20OrderBooks(QueryOrderBooksRequest)\x20returns\x20(QueryOrderBooksRe\
    sponse)\x20{\noption\x20(google.api.http).get\x20=\x20\"/shogun/liquidit\
    y/v1beta1/order_books\";\n}\n}\n\n\n\n\x03\x04\0\x01\x12\x03V\x08\x1a\nS\
    \n\x02\x04\x01\x12\x04Y\0[\x01\x1aG\x20QueryParamsResponse\x20is\x20resp\
    onse\x20type\x20for\x20the\x20Query/Params\x20RPC\x20method.\n\n\n\n\x03\
    \x04\x01\x01\x12\x03Y\x08\x1b\n\x0b\n\x04\x04\x01\x02\0\x12\x03Z\x02\x14\
    \n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03Z\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03Z\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03Z\x12\x13\nO\
    \n\x02\x04\x02\x12\x04^\0d\x01\x1aC\x20QueryPoolsRequest\x20is\x20reques\
    t\x20type\x20for\x20the\x20Query/Pools\x20RPC\x20method.\n\n\n\n\x03\x04\
    \x02\x01\x12\x03^\x08\x19\n\x0b\n\x04\x04\x02\x02\0\x12\x03_\x02\x15\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03_\x02\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03_\t\x10\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03_\x13\x14\n\x0b\
    \n\x04\x04\x02\x02\x01\x12\x03a\x02\x16\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03a\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03a\t\x11\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03a\x14\x15\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03c\x027\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03c\x02'\n\x0c\n\x05\
    \x04\x02\x02\x02\x01\x12\x03c(2\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03c\
    56\nQ\n\x02\x04\x03\x12\x04g\0k\x01\x1aE\x20QueryPoolsResponse\x20is\x20\
    response\x20type\x20for\x20the\x20Query/Pools\x20RPC\x20method.\n\n\n\n\
    \x03\x04\x03\x01\x12\x03g\x08\x1a\n\x0b\n\x04\x04\x03\x02\0\x12\x03h\x02\
    \"\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03h\x02\n\n\x0c\n\x05\x04\x03\x02\
    \0\x06\x12\x03h\x0b\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03h\x18\x1d\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03h\x20!\n\x0b\n\x04\x04\x03\x02\x01\
    \x12\x03j\x028\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03j\x02(\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03j)3\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03j\
    67\nM\n\x02\x04\x04\x12\x04n\0p\x01\x1aA\x20QueryPoolRequest\x20is\x20re\
    quest\x20type\x20for\x20the\x20Query/Pool\x20RPC\x20method.\n\n\n\n\x03\
    \x04\x04\x01\x12\x03n\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x03o\x02\x15\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03o\t\x10\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03o\x13\x14\nO\
    \n\x02\x04\x05\x12\x04s\0u\x01\x1aC\x20QueryPoolResponse\x20is\x20respon\
    se\x20type\x20for\x20the\x20Query/Pool\x20RPC\x20method.\n\n\n\n\x03\x04\
    \x05\x01\x12\x03s\x08\x19\n\x0b\n\x04\x04\x05\x02\0\x12\x03t\x02\x18\n\
    \x0c\n\x05\x04\x05\x02\0\x06\x12\x03t\x02\x0e\n\x0c\n\x05\x04\x05\x02\0\
    \x01\x12\x03t\x0f\x13\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03t\x16\x17\nm\
    \n\x02\x04\x06\x12\x04x\0z\x01\x1aa\x20QueryPoolByReserveAddressRequest\
    \x20is\x20request\x20type\x20for\x20the\x20Query/PoolByReserveAddress\
    \x20RPC\x20method.\n\n\n\n\x03\x04\x06\x01\x12\x03x\x08(\n\x0b\n\x04\x04\
    \x06\x02\0\x12\x03y\x02\x1d\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03y\x02\
    \x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03y\t\x18\n\x0c\n\x05\x04\x06\
    \x02\0\x03\x12\x03y\x1b\x1c\nk\n\x02\x04\x07\x12\x04}\0\x7f\x01\x1a_\x20\
    QueryPoolByPoolCoinDenomRequest\x20is\x20request\x20type\x20for\x20the\
    \x20Query/PoolByPoolCoinDenom\x20RPC\x20method.\n\n\n\n\x03\x04\x07\x01\
    \x12\x03}\x08'\n\x0b\n\x04\x04\x07\x02\0\x12\x03~\x02\x1d\n\x0c\n\x05\
    \x04\x07\x02\0\x05\x12\x03~\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03~\t\x18\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03~\x1b\x1c\nQ\n\x02\x04\
    \x08\x12\x06\x82\x01\0\x86\x01\x01\x1aC\x20QueryPairsRequest\x20is\x20re\
    quest\x20type\x20for\x20the\x20Query/Pairs\x20RPC\x20method.\n\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\x82\x01\x08\x19\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\x83\x01\x02\x1d\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x83\x01\x02\n\n\
    \r\n\x05\x04\x08\x02\0\x05\x12\x04\x83\x01\x0b\x11\n\r\n\x05\x04\x08\x02\
    \0\x01\x12\x04\x83\x01\x12\x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x83\
    \x01\x1b\x1c\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x85\x01\x027\n\r\n\x05\
    \x04\x08\x02\x01\x06\x12\x04\x85\x01\x02'\n\r\n\x05\x04\x08\x02\x01\x01\
    \x12\x04\x85\x01(2\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x85\x0156\nS\n\
    \x02\x04\t\x12\x06\x89\x01\0\x8d\x01\x01\x1aE\x20QueryPairsResponse\x20i\
    s\x20response\x20type\x20for\x20the\x20Query/Pairs\x20RPC\x20method.\n\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x89\x01\x08\x1a\n\x0c\n\x04\x04\t\x02\0\x12\
    \x04\x8a\x01\x02\x1a\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x8a\x01\x02\n\n\r\
    \n\x05\x04\t\x02\0\x06\x12\x04\x8a\x01\x0b\x0f\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\x8a\x01\x10\x15\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x8a\x01\x18\
    \x19\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x8c\x01\x028\n\r\n\x05\x04\t\x02\
    \x01\x06\x12\x04\x8c\x01\x02(\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x8c\
    \x01)3\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8c\x0167\nO\n\x02\x04\n\x12\
    \x06\x90\x01\0\x92\x01\x01\x1aA\x20QueryPairRequest\x20is\x20request\x20\
    type\x20for\x20the\x20Query/Pair\x20RPC\x20method.\n\n\x0b\n\x03\x04\n\
    \x01\x12\x04\x90\x01\x08\x18\n\x0c\n\x04\x04\n\x02\0\x12\x04\x91\x01\x02\
    \x15\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x91\x01\x02\x08\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\x91\x01\t\x10\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x91\
    \x01\x13\x14\nQ\n\x02\x04\x0b\x12\x06\x95\x01\0\x97\x01\x01\x1aC\x20Quer\
    yPairResponse\x20is\x20response\x20type\x20for\x20the\x20Query/Pair\x20R\
    PC\x20method.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x95\x01\x08\x19\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\x96\x01\x02\x10\n\r\n\x05\x04\x0b\x02\0\x06\
    \x12\x04\x96\x01\x02\x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x96\x01\x07\
    \x0b\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x96\x01\x0e\x0f\ne\n\x02\x04\
    \x0c\x12\x06\x9a\x01\0\x9e\x01\x01\x1aW\x20QueryDepositRequestsRequest\
    \x20is\x20request\x20type\x20for\x20the\x20Query/DepositRequests\x20RPC\
    \x20method.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\x9a\x01\x08#\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\x9b\x01\x02\x15\n\r\n\x05\x04\x0c\x02\0\x05\x12\
    \x04\x9b\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x9b\x01\t\x10\n\
    \r\n\x05\x04\x0c\x02\0\x03\x12\x04\x9b\x01\x13\x14\n\x0c\n\x04\x04\x0c\
    \x02\x01\x12\x04\x9d\x01\x027\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\x9d\
    \x01\x02'\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x9d\x01(2\n\r\n\x05\x04\
    \x0c\x02\x01\x03\x12\x04\x9d\x0156\ng\n\x02\x04\r\x12\x06\xa1\x01\0\xa5\
    \x01\x01\x1aY\x20QueryDepositRequestsResponse\x20is\x20response\x20type\
    \x20for\x20the\x20Query/DepositRequests\x20RPC\x20method.\n\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xa1\x01\x08$\n\x0c\n\x04\x04\r\x02\0\x12\x04\xa2\x01\
    \x02/\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\x04\r\
    \x02\0\x06\x12\x04\xa2\x01\x0b\x19\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xa2\
    \x01\x1a*\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xa2\x01-.\n\x0c\n\x04\x04\r\
    \x02\x01\x12\x04\xa4\x01\x028\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xa4\
    \x01\x02(\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xa4\x01)3\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\xa4\x0167\nc\n\x02\x04\x0e\x12\x06\xa8\x01\0\xab\
    \x01\x01\x1aU\x20QueryDepositRequestRequest\x20is\x20request\x20type\x20\
    for\x20the\x20Query/DepositRequest\x20RPC\x20method.\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xa8\x01\x08\"\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xa9\x01\
    \x02\x15\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xa9\x01\t\x10\n\r\n\x05\x04\x0e\x02\0\x03\x12\
    \x04\xa9\x01\x13\x14\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xaa\x01\x02\x15\
    \n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xaa\x01\x02\x08\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xaa\x01\t\x0b\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xaa\x01\x13\x14\ne\n\x02\x04\x0f\x12\x06\xae\x01\0\xb0\x01\x01\x1aW\x20\
    QueryDepositRequestResponse\x20is\x20response\x20type\x20for\x20the\x20Q\
    uery/DepositRequest\x20RPC\x20method.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \xae\x01\x08#\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xaf\x01\x02%\n\r\n\x05\
    \x04\x0f\x02\0\x06\x12\x04\xaf\x01\x02\x10\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xaf\x01\x11\x20\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xaf\x01#$\n\
    g\n\x02\x04\x10\x12\x06\xb3\x01\0\xb7\x01\x01\x1aY\x20QueryWithdrawReque\
    stsRequest\x20is\x20request\x20type\x20for\x20the\x20Query/WithdrawReque\
    sts\x20RPC\x20method.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xb3\x01\x08$\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\xb4\x01\x02\x15\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xb4\x01\x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb4\x01\
    \t\x10\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb4\x01\x13\x14\n\x0c\n\x04\
    \x04\x10\x02\x01\x12\x04\xb6\x01\x027\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xb6\x01\x02'\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xb6\x01(2\n\r\n\
    \x05\x04\x10\x02\x01\x03\x12\x04\xb6\x0156\ni\n\x02\x04\x11\x12\x06\xba\
    \x01\0\xbe\x01\x01\x1a[\x20QueryWithdrawRequestsResponse\x20is\x20respon\
    se\x20type\x20for\x20the\x20Query/WithdrawRequests\x20RPC\x20method.\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xba\x01\x08%\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\xbb\x01\x021\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xbb\x01\x02\n\
    \n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xbb\x01\x0b\x1a\n\r\n\x05\x04\x11\
    \x02\0\x01\x12\x04\xbb\x01\x1b,\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xbb\
    \x01/0\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xbd\x01\x028\n\r\n\x05\x04\
    \x11\x02\x01\x06\x12\x04\xbd\x01\x02(\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xbd\x01)3\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xbd\x0167\ne\n\x02\
    \x04\x12\x12\x06\xc1\x01\0\xc4\x01\x01\x1aW\x20QueryWithdrawRequestReque\
    st\x20is\x20request\x20type\x20for\x20the\x20Query/WithdrawRequest\x20RP\
    C\x20method.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xc1\x01\x08#\n\x0c\n\x04\
    \x04\x12\x02\0\x12\x04\xc2\x01\x02\x15\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\xc2\x01\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc2\x01\t\x10\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\xc2\x01\x13\x14\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xc3\x01\x02\x15\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xc3\x01\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xc3\x01\t\x0b\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xc3\x01\x13\x14\ng\n\x02\x04\x13\x12\
    \x06\xc7\x01\0\xc9\x01\x01\x1aY\x20QueryWithdrawRequestResponse\x20is\
    \x20response\x20type\x20for\x20the\x20Query/WithdrawRequest\x20RPC\x20me\
    thod.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xc7\x01\x08$\n\x0c\n\x04\x04\x13\
    \x02\0\x12\x04\xc8\x01\x02'\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xc8\x01\
    \x02\x11\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xc8\x01\x12\"\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\xc8\x01%&\nS\n\x02\x04\x14\x12\x06\xcc\x01\0\xd0\
    \x01\x01\x1aE\x20QueryOrdersRequest\x20is\x20request\x20type\x20for\x20t\
    he\x20Query/Orders\x20RPC\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xcc\x01\x08\x1a\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xcd\x01\x02\x15\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\xcd\x01\x02\x08\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\xcd\x01\t\x10\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xcd\x01\
    \x13\x14\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xcf\x01\x027\n\r\n\x05\x04\
    \x14\x02\x01\x06\x12\x04\xcf\x01\x02'\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xcf\x01(2\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xcf\x0156\nU\n\x02\
    \x04\x15\x12\x06\xd3\x01\0\xd7\x01\x01\x1aG\x20QueryOrdersResponse\x20is\
    \x20response\x20type\x20for\x20the\x20Query/Orders\x20RPC\x20method.\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xd3\x01\x08\x1b\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xd4\x01\x02\x1c\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xd4\x01\x02\
    \n\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\xd4\x01\x0b\x10\n\r\n\x05\x04\x15\
    \x02\0\x01\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\
    \xd4\x01\x1a\x1b\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xd6\x01\x028\n\r\n\
    \x05\x04\x15\x02\x01\x06\x12\x04\xd6\x01\x02(\n\r\n\x05\x04\x15\x02\x01\
    \x01\x12\x04\xd6\x01)3\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xd6\x0167\n\
    Q\n\x02\x04\x16\x12\x06\xda\x01\0\xdd\x01\x01\x1aC\x20QueryOrderRequest\
    \x20is\x20request\x20type\x20for\x20the\x20Query/Order\x20RPC\x20method.\
    \n\n\x0b\n\x03\x04\x16\x01\x12\x04\xda\x01\x08\x19\n\x0c\n\x04\x04\x16\
    \x02\0\x12\x04\xdb\x01\x02\x15\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xdb\
    \x01\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xdb\x01\t\x10\n\r\n\x05\
    \x04\x16\x02\0\x03\x12\x04\xdb\x01\x13\x14\n\x0c\n\x04\x04\x16\x02\x01\
    \x12\x04\xdc\x01\x02\x15\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xdc\x01\
    \x02\x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xdc\x01\t\x0b\n\r\n\x05\
    \x04\x16\x02\x01\x03\x12\x04\xdc\x01\x13\x14\nS\n\x02\x04\x17\x12\x06\
    \xe0\x01\0\xe2\x01\x01\x1aE\x20QueryOrderResponse\x20is\x20response\x20t\
    ype\x20for\x20the\x20Query/Order\x20RPC\x20method.\n\n\x0b\n\x03\x04\x17\
    \x01\x12\x04\xe0\x01\x08\x1a\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xe1\x01\
    \x02\x12\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xe1\x01\x02\x07\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\xe1\x01\x08\r\n\r\n\x05\x04\x17\x02\0\x03\x12\
    \x04\xe1\x01\x10\x11\ne\n\x02\x04\x18\x12\x06\xe5\x01\0\xe9\x01\x01\x1aW\
    \x20QueryOrdersByOrdererRequest\x20is\x20request\x20type\x20for\x20the\
    \x20Query/OrdersByOrderer\x20RPC\x20method.\n\n\x0b\n\x03\x04\x18\x01\
    \x12\x04\xe5\x01\x08#\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xe6\x01\x027\n\r\
    \n\x05\x04\x18\x02\0\x05\x12\x04\xe6\x01\x02\x08\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xe6\x01(/\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xe6\x0156\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\xe7\x01\x027\n\r\n\x05\x04\x18\x02\
    \x01\x05\x12\x04\xe7\x01\x02\x08\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\
    \xe7\x01(/\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xe7\x0156\n\x0c\n\x04\
    \x04\x18\x02\x02\x12\x04\xe8\x01\x027\n\r\n\x05\x04\x18\x02\x02\x06\x12\
    \x04\xe8\x01\x02'\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xe8\x01(2\n\r\n\
    \x05\x04\x18\x02\x02\x03\x12\x04\xe8\x0156\n[\n\x02\x04\x19\x12\x06\xec\
    \x01\0\xf0\x01\x01\x1aM\x20QueryOrderBooksRequest\x20is\x20request\x20ty\
    pe\x20for\x20the\x20Query/OrderBooks\x20RPC\x20method.\n\n\x0b\n\x03\x04\
    \x19\x01\x12\x04\xec\x01\x08\x1e\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xed\
    \x01\x02(\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\
    \x04\x19\x02\0\x05\x12\x04\xed\x01\x0b\x11\n\r\n\x05\x04\x19\x02\0\x01\
    \x12\x04\xed\x01\x12\x1a\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xed\x01&'\n\
    \x0c\n\x04\x04\x19\x02\x01\x12\x04\xee\x01\x02(\n\r\n\x05\x04\x19\x02\
    \x01\x04\x12\x04\xee\x01\x02\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xee\
    \x01\x0b\x11\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xee\x01\x12#\n\r\n\
    \x05\x04\x19\x02\x01\x03\x12\x04\xee\x01&'\n\x0c\n\x04\x04\x19\x02\x02\
    \x12\x04\xef\x01\x02(\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xef\x01\x02\
    \x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xef\x01\x12\x1b\n\r\n\x05\x04\
    \x19\x02\x02\x03\x12\x04\xef\x01&'\nY\n\x02\x04\x1a\x12\x06\xf3\x01\0\
    \xf5\x01\x01\x1aK\x20QueryOrderBooksResponse\x20is\x20response\x20type\
    \x20for\x20Query/OrderBooks\x20RPC\x20method.\n\n\x0b\n\x03\x04\x1a\x01\
    \x12\x04\xf3\x01\x08\x1f\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xf4\x01\x02+\
    \n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xf4\x01\x02\n\n\r\n\x05\x04\x1a\x02\
    \0\x06\x12\x04\xf4\x01\x0b\x20\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xf4\
    \x01!&\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xf4\x01)*\nb\n\x02\x04\x1b\
    \x12\x06\xfc\x01\0\x98\x02\x01\x1a6\x20PoolResponse\x20defines\x20a\x20c\
    ustom\x20pool\x20response\x20message.\n2\x1c\n\x20Custom\x20response\x20\
    messages\n\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xfc\x01\x08\x14\n\x0c\n\x04\
    \x04\x1b\x02\0\x12\x04\xfd\x01\x02\x14\n\r\n\x05\x04\x1b\x02\0\x06\x12\
    \x04\xfd\x01\x02\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xfd\x01\x0b\x0f\n\
    \r\n\x05\x04\x1b\x02\0\x03\x12\x04\xfd\x01\x12\x13\n\x0c\n\x04\x04\x1b\
    \x02\x01\x12\x04\xff\x01\x02\x10\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\
    \xff\x01\x02\x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xff\x01\t\x0b\n\r\
    \n\x05\x04\x1b\x02\x01\x03\x12\x04\xff\x01\x0e\x0f\n\x0c\n\x04\x04\x1b\
    \x02\x02\x12\x04\x81\x02\x02\x15\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\
    \x81\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\x81\x02\t\x10\n\r\
    \n\x05\x04\x1b\x02\x02\x03\x12\x04\x81\x02\x13\x14\n\x0c\n\x04\x04\x1b\
    \x02\x03\x12\x04\x83\x02\x02\x15\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\
    \x83\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x03\x01\x12\x04\x83\x02\t\x10\n\r\
    \n\x05\x04\x1b\x02\x03\x03\x12\x04\x83\x02\x13\x14\n\x0c\n\x04\x04\x1b\
    \x02\x04\x12\x04\x85\x02\x02\x1d\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\
    \x85\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\x85\x02\t\x18\n\r\
    \n\x05\x04\x1b\x02\x04\x03\x12\x04\x85\x02\x1b\x1c\n\x0c\n\x04\x04\x1b\
    \x02\x05\x12\x04\x87\x02\x02\x1d\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\
    \x87\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x05\x01\x12\x04\x87\x02\t\x18\n\r\
    \n\x05\x04\x1b\x02\x05\x03\x12\x04\x87\x02\x1b\x1c\n\x0c\n\x04\x04\x1b\
    \x02\x06\x12\x04\x89\x02\x02\x1e\n\r\n\x05\x04\x1b\x02\x06\x05\x12\x04\
    \x89\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x06\x01\x12\x04\x89\x02\t\x19\n\r\
    \n\x05\x04\x1b\x02\x06\x03\x12\x04\x89\x02\x1c\x1d\n\x0c\n\x04\x04\x1b\
    \x02\x07\x12\x04\x8b\x02\x02\x17\n\r\n\x05\x04\x1b\x02\x07\x05\x12\x04\
    \x8b\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\x8b\x02\t\x12\n\r\
    \n\x05\x04\x1b\x02\x07\x03\x12\x04\x8b\x02\x15\x16\n\x0c\n\x04\x04\x1b\
    \x02\x08\x12\x04\x8d\x02\x02\x17\n\r\n\x05\x04\x1b\x02\x08\x05\x12\x04\
    \x8d\x02\x02\x08\n\r\n\x05\x04\x1b\x02\x08\x01\x12\x04\x8d\x02\t\x12\n\r\
    \n\x05\x04\x1b\x02\x08\x03\x12\x04\x8d\x02\x15\x16\n\x0c\n\x04\x04\x1b\
    \x02\t\x12\x04\x8f\x02\x02\x14\n\r\n\x05\x04\x1b\x02\t\x05\x12\x04\x8f\
    \x02\x02\x08\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\x8f\x02\t\x0e\n\r\n\x05\
    \x04\x1b\x02\t\x03\x12\x04\x8f\x02\x11\x13\n\x0c\n\x04\x04\x1b\x02\n\x12\
    \x04\x91\x02\x02\x1d\n\r\n\x05\x04\x1b\x02\n\x06\x12\x04\x91\x02\x02\x0e\
    \n\r\n\x05\x04\x1b\x02\n\x01\x12\x04\x91\x02\x0f\x17\n\r\n\x05\x04\x1b\
    \x02\n\x03\x12\x04\x91\x02\x1a\x1c\n\x0c\n\x04\x04\x1b\x02\x0b\x12\x04\
    \x93\x02\x02&\n\r\n\x05\x04\x1b\x02\x0b\x05\x12\x04\x93\x02\x02\x08\n\r\
    \n\x05\x04\x1b\x02\x0b\x01\x12\x04\x93\x02\t\x20\n\r\n\x05\x04\x1b\x02\
    \x0b\x03\x12\x04\x93\x02#%\n\x0c\n\x04\x04\x1b\x02\x0c\x12\x04\x95\x02\
    \x02'\n\r\n\x05\x04\x1b\x02\x0c\x05\x12\x04\x95\x02\x02\x08\n\r\n\x05\
    \x04\x1b\x02\x0c\x01\x12\x04\x95\x02\t!\n\r\n\x05\x04\x1b\x02\x0c\x03\
    \x12\x04\x95\x02$&\n\x0c\n\x04\x04\x1b\x02\r\x12\x04\x97\x02\x02\x15\n\r\
    \n\x05\x04\x1b\x02\r\x05\x12\x04\x97\x02\x02\x06\n\r\n\x05\x04\x1b\x02\r\
    \x01\x12\x04\x97\x02\x07\x0f\n\r\n\x05\x04\x1b\x02\r\x03\x12\x04\x97\x02\
    \x12\x14\n\x0c\n\x02\x04\x1c\x12\x06\x9a\x02\0\x9e\x02\x01\n\x0b\n\x03\
    \x04\x1c\x01\x12\x04\x9a\x02\x08\x14\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\
    \x9b\x02\x02)\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\x9b\x02\x02\x1a\n\r\n\
    \x05\x04\x1c\x02\0\x01\x12\x04\x9b\x02\x1b$\n\r\n\x05\x04\x1c\x02\0\x03\
    \x12\x04\x9b\x02'(\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\x9d\x02\x02*\n\r\
    \n\x05\x04\x1c\x02\x01\x06\x12\x04\x9d\x02\x02\x1a\n\r\n\x05\x04\x1c\x02\
    \x01\x01\x12\x04\x9d\x02\x1b%\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\x9d\
    \x02()\n\x0c\n\x02\x04\x1d\x12\x06\xa0\x02\0\xa4\x02\x01\n\x0b\n\x03\x04\
    \x1d\x01\x12\x04\xa0\x02\x08\x1d\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xa1\
    \x02\x02\x18\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xa1\x02\x02\x08\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xa1\x02\t\x10\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xa1\x02\x16\x17\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xa2\x02\x02\
    \x18\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\xa2\x02\x02\x08\n\r\n\x05\x04\
    \x1d\x02\x01\x01\x12\x04\xa2\x02\t\x13\n\r\n\x05\x04\x1d\x02\x01\x03\x12\
    \x04\xa2\x02\x16\x17\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xa3\x02\x02-\n\
    \r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xa3\x02\x02\n\n\r\n\x05\x04\x1d\x02\
    \x02\x06\x12\x04\xa3\x02\x0b\x1c\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\
    \xa3\x02\x1d(\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xa3\x02+,\n\x0c\n\
    \x02\x04\x1e\x12\x06\xa6\x02\0\xaa\x02\x01\n\x0b\n\x03\x04\x1e\x01\x12\
    \x04\xa6\x02\x08\x19\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xa7\x02\x02\x18\n\
    \r\n\x05\x04\x1e\x02\0\x05\x12\x04\xa7\x02\x02\x08\n\r\n\x05\x04\x1e\x02\
    \0\x01\x12\x04\xa7\x02\t\x13\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xa7\x02\
    \x16\x17\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xa8\x02\x02+\n\r\n\x05\x04\
    \x1e\x02\x01\x04\x12\x04\xa8\x02\x02\n\n\r\n\x05\x04\x1e\x02\x01\x06\x12\
    \x04\xa8\x02\x0b\x20\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xa8\x02!&\n\r\
    \n\x05\x04\x1e\x02\x01\x03\x12\x04\xa8\x02)*\n\x0c\n\x04\x04\x1e\x02\x02\
    \x12\x04\xa9\x02\x02+\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\xa9\x02\x02\
    \n\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\xa9\x02\x0b\x20\n\r\n\x05\x04\
    \x1e\x02\x02\x01\x12\x04\xa9\x02!%\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\
    \xa9\x02)*\n\x0c\n\x02\x04\x1f\x12\x06\xac\x02\0\xb0\x02\x01\n\x0b\n\x03\
    \x04\x1f\x01\x12\x04\xac\x02\x08\x1d\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\
    \xad\x02\x02\x13\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xad\x02\x02\x08\n\r\
    \n\x05\x04\x1f\x02\0\x01\x12\x04\xad\x02\t\x0e\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xad\x02\x11\x12\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xae\x02\
    \x02\x1f\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xae\x02\x02\x08\n\r\n\x05\
    \x04\x1f\x02\x01\x01\x12\x04\xae\x02\t\x1a\n\r\n\x05\x04\x1f\x02\x01\x03\
    \x12\x04\xae\x02\x1d\x1e\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\xaf\x02\x02\
    \x1f\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xaf\x02\x02\x08\n\r\n\x05\x04\
    \x1f\x02\x02\x01\x12\x04\xaf\x02\t\x1a\n\r\n\x05\x04\x1f\x02\x02\x03\x12\
    \x04\xaf\x02\x1d\x1eb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::coin::file_descriptor().clone());
            deps.push(super::pagination::file_descriptor().clone());
            deps.push(super::liquidity::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(32);
            messages.push(QueryParamsRequest::generated_message_descriptor_data());
            messages.push(QueryParamsResponse::generated_message_descriptor_data());
            messages.push(QueryPoolsRequest::generated_message_descriptor_data());
            messages.push(QueryPoolsResponse::generated_message_descriptor_data());
            messages.push(QueryPoolRequest::generated_message_descriptor_data());
            messages.push(QueryPoolResponse::generated_message_descriptor_data());
            messages.push(QueryPoolByReserveAddressRequest::generated_message_descriptor_data());
            messages.push(QueryPoolByPoolCoinDenomRequest::generated_message_descriptor_data());
            messages.push(QueryPairsRequest::generated_message_descriptor_data());
            messages.push(QueryPairsResponse::generated_message_descriptor_data());
            messages.push(QueryPairRequest::generated_message_descriptor_data());
            messages.push(QueryPairResponse::generated_message_descriptor_data());
            messages.push(QueryDepositRequestsRequest::generated_message_descriptor_data());
            messages.push(QueryDepositRequestsResponse::generated_message_descriptor_data());
            messages.push(QueryDepositRequestRequest::generated_message_descriptor_data());
            messages.push(QueryDepositRequestResponse::generated_message_descriptor_data());
            messages.push(QueryWithdrawRequestsRequest::generated_message_descriptor_data());
            messages.push(QueryWithdrawRequestsResponse::generated_message_descriptor_data());
            messages.push(QueryWithdrawRequestRequest::generated_message_descriptor_data());
            messages.push(QueryWithdrawRequestResponse::generated_message_descriptor_data());
            messages.push(QueryOrdersRequest::generated_message_descriptor_data());
            messages.push(QueryOrdersResponse::generated_message_descriptor_data());
            messages.push(QueryOrderRequest::generated_message_descriptor_data());
            messages.push(QueryOrderResponse::generated_message_descriptor_data());
            messages.push(QueryOrdersByOrdererRequest::generated_message_descriptor_data());
            messages.push(QueryOrderBooksRequest::generated_message_descriptor_data());
            messages.push(QueryOrderBooksResponse::generated_message_descriptor_data());
            messages.push(PoolResponse::generated_message_descriptor_data());
            messages.push(PoolBalances::generated_message_descriptor_data());
            messages.push(OrderBookPairResponse::generated_message_descriptor_data());
            messages.push(OrderBookResponse::generated_message_descriptor_data());
            messages.push(OrderBookTickResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

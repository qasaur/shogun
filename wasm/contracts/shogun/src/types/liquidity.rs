// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `liquidity.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Params defines the parameters for the liquidity module.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.Params)
pub struct Params {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.batch_size)
    pub batch_size: u32,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.tick_precision)
    pub tick_precision: u32,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.fee_collector_address)
    pub fee_collector_address: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.dust_collector_address)
    pub dust_collector_address: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.min_initial_pool_coin_supply)
    pub min_initial_pool_coin_supply: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.pair_creation_fee)
    pub pair_creation_fee: ::std::vec::Vec<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.pool_creation_fee)
    pub pool_creation_fee: ::std::vec::Vec<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.min_initial_deposit_amount)
    pub min_initial_deposit_amount: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.max_price_limit_ratio)
    pub max_price_limit_ratio: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.max_num_market_making_order_ticks)
    pub max_num_market_making_order_ticks: u32,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.max_order_lifespan)
    pub max_order_lifespan: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.swap_fee_rate)
    pub swap_fee_rate: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.withdraw_fee_rate)
    pub withdraw_fee_rate: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.deposit_extra_gas)
    pub deposit_extra_gas: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.withdraw_extra_gas)
    pub withdraw_extra_gas: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.order_extra_gas)
    pub order_extra_gas: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Params.max_num_active_pools_per_pair)
    pub max_num_active_pools_per_pair: u32,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.Params.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batch_size",
            |m: &Params| { &m.batch_size },
            |m: &mut Params| { &mut m.batch_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tick_precision",
            |m: &Params| { &m.tick_precision },
            |m: &mut Params| { &mut m.tick_precision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fee_collector_address",
            |m: &Params| { &m.fee_collector_address },
            |m: &mut Params| { &mut m.fee_collector_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dust_collector_address",
            |m: &Params| { &m.dust_collector_address },
            |m: &mut Params| { &mut m.dust_collector_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_initial_pool_coin_supply",
            |m: &Params| { &m.min_initial_pool_coin_supply },
            |m: &mut Params| { &mut m.min_initial_pool_coin_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pair_creation_fee",
            |m: &Params| { &m.pair_creation_fee },
            |m: &mut Params| { &mut m.pair_creation_fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pool_creation_fee",
            |m: &Params| { &m.pool_creation_fee },
            |m: &mut Params| { &mut m.pool_creation_fee },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_initial_deposit_amount",
            |m: &Params| { &m.min_initial_deposit_amount },
            |m: &mut Params| { &mut m.min_initial_deposit_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_price_limit_ratio",
            |m: &Params| { &m.max_price_limit_ratio },
            |m: &mut Params| { &mut m.max_price_limit_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_num_market_making_order_ticks",
            |m: &Params| { &m.max_num_market_making_order_ticks },
            |m: &mut Params| { &mut m.max_num_market_making_order_ticks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "max_order_lifespan",
            |m: &Params| { &m.max_order_lifespan },
            |m: &mut Params| { &mut m.max_order_lifespan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "swap_fee_rate",
            |m: &Params| { &m.swap_fee_rate },
            |m: &mut Params| { &mut m.swap_fee_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdraw_fee_rate",
            |m: &Params| { &m.withdraw_fee_rate },
            |m: &mut Params| { &mut m.withdraw_fee_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deposit_extra_gas",
            |m: &Params| { &m.deposit_extra_gas },
            |m: &mut Params| { &mut m.deposit_extra_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdraw_extra_gas",
            |m: &Params| { &m.withdraw_extra_gas },
            |m: &mut Params| { &mut m.withdraw_extra_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_extra_gas",
            |m: &Params| { &m.order_extra_gas },
            |m: &mut Params| { &mut m.order_extra_gas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_num_active_pools_per_pair",
            |m: &Params| { &m.max_num_active_pools_per_pair },
            |m: &mut Params| { &mut m.max_num_active_pools_per_pair },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Params>(
            "Params",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Params {
    const NAME: &'static str = "Params";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.batch_size = is.read_uint32()?;
                },
                16 => {
                    self.tick_precision = is.read_uint32()?;
                },
                26 => {
                    self.fee_collector_address = is.read_string()?;
                },
                34 => {
                    self.dust_collector_address = is.read_string()?;
                },
                42 => {
                    self.min_initial_pool_coin_supply = is.read_string()?;
                },
                50 => {
                    self.pair_creation_fee.push(is.read_message()?);
                },
                58 => {
                    self.pool_creation_fee.push(is.read_message()?);
                },
                66 => {
                    self.min_initial_deposit_amount = is.read_string()?;
                },
                74 => {
                    self.max_price_limit_ratio = is.read_string()?;
                },
                80 => {
                    self.max_num_market_making_order_ticks = is.read_uint32()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_order_lifespan)?;
                },
                98 => {
                    self.swap_fee_rate = is.read_string()?;
                },
                106 => {
                    self.withdraw_fee_rate = is.read_string()?;
                },
                112 => {
                    self.deposit_extra_gas = is.read_uint64()?;
                },
                120 => {
                    self.withdraw_extra_gas = is.read_uint64()?;
                },
                128 => {
                    self.order_extra_gas = is.read_uint64()?;
                },
                136 => {
                    self.max_num_active_pools_per_pair = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.batch_size);
        }
        if self.tick_precision != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.tick_precision);
        }
        if !self.fee_collector_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fee_collector_address);
        }
        if !self.dust_collector_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dust_collector_address);
        }
        if !self.min_initial_pool_coin_supply.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.min_initial_pool_coin_supply);
        }
        for value in &self.pair_creation_fee {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pool_creation_fee {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.min_initial_deposit_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.min_initial_deposit_amount);
        }
        if !self.max_price_limit_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.max_price_limit_ratio);
        }
        if self.max_num_market_making_order_ticks != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.max_num_market_making_order_ticks);
        }
        if let Some(v) = self.max_order_lifespan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.swap_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.swap_fee_rate);
        }
        if !self.withdraw_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.withdraw_fee_rate);
        }
        if self.deposit_extra_gas != 0 {
            my_size += ::protobuf::rt::uint64_size(14, self.deposit_extra_gas);
        }
        if self.withdraw_extra_gas != 0 {
            my_size += ::protobuf::rt::uint64_size(15, self.withdraw_extra_gas);
        }
        if self.order_extra_gas != 0 {
            my_size += ::protobuf::rt::uint64_size(16, self.order_extra_gas);
        }
        if self.max_num_active_pools_per_pair != 0 {
            my_size += ::protobuf::rt::uint32_size(17, self.max_num_active_pools_per_pair);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.batch_size != 0 {
            os.write_uint32(1, self.batch_size)?;
        }
        if self.tick_precision != 0 {
            os.write_uint32(2, self.tick_precision)?;
        }
        if !self.fee_collector_address.is_empty() {
            os.write_string(3, &self.fee_collector_address)?;
        }
        if !self.dust_collector_address.is_empty() {
            os.write_string(4, &self.dust_collector_address)?;
        }
        if !self.min_initial_pool_coin_supply.is_empty() {
            os.write_string(5, &self.min_initial_pool_coin_supply)?;
        }
        for v in &self.pair_creation_fee {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.pool_creation_fee {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if !self.min_initial_deposit_amount.is_empty() {
            os.write_string(8, &self.min_initial_deposit_amount)?;
        }
        if !self.max_price_limit_ratio.is_empty() {
            os.write_string(9, &self.max_price_limit_ratio)?;
        }
        if self.max_num_market_making_order_ticks != 0 {
            os.write_uint32(10, self.max_num_market_making_order_ticks)?;
        }
        if let Some(v) = self.max_order_lifespan.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if !self.swap_fee_rate.is_empty() {
            os.write_string(12, &self.swap_fee_rate)?;
        }
        if !self.withdraw_fee_rate.is_empty() {
            os.write_string(13, &self.withdraw_fee_rate)?;
        }
        if self.deposit_extra_gas != 0 {
            os.write_uint64(14, self.deposit_extra_gas)?;
        }
        if self.withdraw_extra_gas != 0 {
            os.write_uint64(15, self.withdraw_extra_gas)?;
        }
        if self.order_extra_gas != 0 {
            os.write_uint64(16, self.order_extra_gas)?;
        }
        if self.max_num_active_pools_per_pair != 0 {
            os.write_uint32(17, self.max_num_active_pools_per_pair)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Params {
        Params::new()
    }

    fn clear(&mut self) {
        self.batch_size = 0;
        self.tick_precision = 0;
        self.fee_collector_address.clear();
        self.dust_collector_address.clear();
        self.min_initial_pool_coin_supply.clear();
        self.pair_creation_fee.clear();
        self.pool_creation_fee.clear();
        self.min_initial_deposit_amount.clear();
        self.max_price_limit_ratio.clear();
        self.max_num_market_making_order_ticks = 0;
        self.max_order_lifespan.clear();
        self.swap_fee_rate.clear();
        self.withdraw_fee_rate.clear();
        self.deposit_extra_gas = 0;
        self.withdraw_extra_gas = 0;
        self.order_extra_gas = 0;
        self.max_num_active_pools_per_pair = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Params {
        static instance: Params = Params {
            batch_size: 0,
            tick_precision: 0,
            fee_collector_address: ::std::string::String::new(),
            dust_collector_address: ::std::string::String::new(),
            min_initial_pool_coin_supply: ::std::string::String::new(),
            pair_creation_fee: ::std::vec::Vec::new(),
            pool_creation_fee: ::std::vec::Vec::new(),
            min_initial_deposit_amount: ::std::string::String::new(),
            max_price_limit_ratio: ::std::string::String::new(),
            max_num_market_making_order_ticks: 0,
            max_order_lifespan: ::protobuf::MessageField::none(),
            swap_fee_rate: ::std::string::String::new(),
            withdraw_fee_rate: ::std::string::String::new(),
            deposit_extra_gas: 0,
            withdraw_extra_gas: 0,
            order_extra_gas: 0,
            max_num_active_pools_per_pair: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Params {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Params").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Pair defines a coin pair.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.Pair)
pub struct Pair {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.id)
    pub id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.base_coin_denom)
    pub base_coin_denom: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.quote_coin_denom)
    pub quote_coin_denom: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.escrow_address)
    pub escrow_address: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.last_order_id)
    pub last_order_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.last_price)
    pub last_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pair.current_batch_id)
    pub current_batch_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.Pair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pair {
    fn default() -> &'a Pair {
        <Pair as ::protobuf::Message>::default_instance()
    }
}

impl Pair {
    pub fn new() -> Pair {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Pair| { &m.id },
            |m: &mut Pair| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "base_coin_denom",
            |m: &Pair| { &m.base_coin_denom },
            |m: &mut Pair| { &mut m.base_coin_denom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quote_coin_denom",
            |m: &Pair| { &m.quote_coin_denom },
            |m: &mut Pair| { &mut m.quote_coin_denom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "escrow_address",
            |m: &Pair| { &m.escrow_address },
            |m: &mut Pair| { &mut m.escrow_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_order_id",
            |m: &Pair| { &m.last_order_id },
            |m: &mut Pair| { &mut m.last_order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_price",
            |m: &Pair| { &m.last_price },
            |m: &mut Pair| { &mut m.last_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_batch_id",
            |m: &Pair| { &m.current_batch_id },
            |m: &mut Pair| { &mut m.current_batch_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pair>(
            "Pair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pair {
    const NAME: &'static str = "Pair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                18 => {
                    self.base_coin_denom = is.read_string()?;
                },
                26 => {
                    self.quote_coin_denom = is.read_string()?;
                },
                34 => {
                    self.escrow_address = is.read_string()?;
                },
                40 => {
                    self.last_order_id = is.read_uint64()?;
                },
                50 => {
                    self.last_price = is.read_string()?;
                },
                56 => {
                    self.current_batch_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if !self.base_coin_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_coin_denom);
        }
        if !self.quote_coin_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_coin_denom);
        }
        if !self.escrow_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.escrow_address);
        }
        if self.last_order_id != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.last_order_id);
        }
        if !self.last_price.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.last_price);
        }
        if self.current_batch_id != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.current_batch_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if !self.base_coin_denom.is_empty() {
            os.write_string(2, &self.base_coin_denom)?;
        }
        if !self.quote_coin_denom.is_empty() {
            os.write_string(3, &self.quote_coin_denom)?;
        }
        if !self.escrow_address.is_empty() {
            os.write_string(4, &self.escrow_address)?;
        }
        if self.last_order_id != 0 {
            os.write_uint64(5, self.last_order_id)?;
        }
        if !self.last_price.is_empty() {
            os.write_string(6, &self.last_price)?;
        }
        if self.current_batch_id != 0 {
            os.write_uint64(7, self.current_batch_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pair {
        Pair::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.base_coin_denom.clear();
        self.quote_coin_denom.clear();
        self.escrow_address.clear();
        self.last_order_id = 0;
        self.last_price.clear();
        self.current_batch_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pair {
        static instance: Pair = Pair {
            id: 0,
            base_coin_denom: ::std::string::String::new(),
            quote_coin_denom: ::std::string::String::new(),
            escrow_address: ::std::string::String::new(),
            last_order_id: 0,
            last_price: ::std::string::String::new(),
            current_batch_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Pool defines generic liquidity pool object which can be either a basic pool or a
///  ranged pool.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.Pool)
pub struct Pool {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.type)
    pub type_: ::protobuf::EnumOrUnknown<PoolType>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.id)
    pub id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.reserve_address)
    pub reserve_address: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.pool_coin_denom)
    pub pool_coin_denom: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.min_price)
    pub min_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.max_price)
    pub max_price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.last_deposit_request_id)
    pub last_deposit_request_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.last_withdraw_request_id)
    pub last_withdraw_request_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Pool.disabled)
    pub disabled: bool,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.Pool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pool {
    fn default() -> &'a Pool {
        <Pool as ::protobuf::Message>::default_instance()
    }
}

impl Pool {
    pub fn new() -> Pool {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Pool| { &m.type_ },
            |m: &mut Pool| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Pool| { &m.id },
            |m: &mut Pool| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &Pool| { &m.pair_id },
            |m: &mut Pool| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &Pool| { &m.creator },
            |m: &mut Pool| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reserve_address",
            |m: &Pool| { &m.reserve_address },
            |m: &mut Pool| { &mut m.reserve_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_coin_denom",
            |m: &Pool| { &m.pool_coin_denom },
            |m: &mut Pool| { &mut m.pool_coin_denom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_price",
            |m: &Pool| { &m.min_price },
            |m: &mut Pool| { &mut m.min_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_price",
            |m: &Pool| { &m.max_price },
            |m: &mut Pool| { &mut m.max_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_deposit_request_id",
            |m: &Pool| { &m.last_deposit_request_id },
            |m: &mut Pool| { &mut m.last_deposit_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_withdraw_request_id",
            |m: &Pool| { &m.last_withdraw_request_id },
            |m: &mut Pool| { &mut m.last_withdraw_request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled",
            |m: &Pool| { &m.disabled },
            |m: &mut Pool| { &mut m.disabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pool>(
            "Pool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pool {
    const NAME: &'static str = "Pool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                24 => {
                    self.pair_id = is.read_uint64()?;
                },
                34 => {
                    self.creator = is.read_string()?;
                },
                42 => {
                    self.reserve_address = is.read_string()?;
                },
                50 => {
                    self.pool_coin_denom = is.read_string()?;
                },
                58 => {
                    self.min_price = is.read_string()?;
                },
                66 => {
                    self.max_price = is.read_string()?;
                },
                72 => {
                    self.last_deposit_request_id = is.read_uint64()?;
                },
                80 => {
                    self.last_withdraw_request_id = is.read_uint64()?;
                },
                88 => {
                    self.disabled = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(PoolType::POOL_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.pair_id);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.creator);
        }
        if !self.reserve_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.reserve_address);
        }
        if !self.pool_coin_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.pool_coin_denom);
        }
        if !self.min_price.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.min_price);
        }
        if !self.max_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.max_price);
        }
        if self.last_deposit_request_id != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.last_deposit_request_id);
        }
        if self.last_withdraw_request_id != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.last_withdraw_request_id);
        }
        if self.disabled != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(PoolType::POOL_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if self.pair_id != 0 {
            os.write_uint64(3, self.pair_id)?;
        }
        if !self.creator.is_empty() {
            os.write_string(4, &self.creator)?;
        }
        if !self.reserve_address.is_empty() {
            os.write_string(5, &self.reserve_address)?;
        }
        if !self.pool_coin_denom.is_empty() {
            os.write_string(6, &self.pool_coin_denom)?;
        }
        if !self.min_price.is_empty() {
            os.write_string(7, &self.min_price)?;
        }
        if !self.max_price.is_empty() {
            os.write_string(8, &self.max_price)?;
        }
        if self.last_deposit_request_id != 0 {
            os.write_uint64(9, self.last_deposit_request_id)?;
        }
        if self.last_withdraw_request_id != 0 {
            os.write_uint64(10, self.last_withdraw_request_id)?;
        }
        if self.disabled != false {
            os.write_bool(11, self.disabled)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pool {
        Pool::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(PoolType::POOL_TYPE_UNSPECIFIED);
        self.id = 0;
        self.pair_id = 0;
        self.creator.clear();
        self.reserve_address.clear();
        self.pool_coin_denom.clear();
        self.min_price.clear();
        self.max_price.clear();
        self.last_deposit_request_id = 0;
        self.last_withdraw_request_id = 0;
        self.disabled = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pool {
        static instance: Pool = Pool {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: 0,
            pair_id: 0,
            creator: ::std::string::String::new(),
            reserve_address: ::std::string::String::new(),
            pool_coin_denom: ::std::string::String::new(),
            min_price: ::std::string::String::new(),
            max_price: ::std::string::String::new(),
            last_deposit_request_id: 0,
            last_withdraw_request_id: 0,
            disabled: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DepositRequest defines a deposit request.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.DepositRequest)
pub struct DepositRequest {
    // message fields
    ///  id specifies the id for the request
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.id)
    pub id: u64,
    ///  pool_id specifies the pool id
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.pool_id)
    pub pool_id: u64,
    ///  msg_height specifies the block height when the request is stored for the batch execution
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.msg_height)
    pub msg_height: i64,
    ///  depositor specifies the bech32-encoded address that makes a deposit to the pool
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.depositor)
    pub depositor: ::std::string::String,
    ///  deposit_coins specifies the amount of coins to deposit.
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.deposit_coins)
    pub deposit_coins: ::std::vec::Vec<super::coin::Coin>,
    ///  accepted_coins specifies the amount of coins that are accepted.
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.accepted_coins)
    pub accepted_coins: ::std::vec::Vec<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.minted_pool_coin)
    pub minted_pool_coin: ::protobuf::MessageField<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.DepositRequest.status)
    pub status: ::protobuf::EnumOrUnknown<RequestStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.DepositRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DepositRequest {
    fn default() -> &'a DepositRequest {
        <DepositRequest as ::protobuf::Message>::default_instance()
    }
}

impl DepositRequest {
    pub fn new() -> DepositRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DepositRequest| { &m.id },
            |m: &mut DepositRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &DepositRequest| { &m.pool_id },
            |m: &mut DepositRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_height",
            |m: &DepositRequest| { &m.msg_height },
            |m: &mut DepositRequest| { &mut m.msg_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "depositor",
            |m: &DepositRequest| { &m.depositor },
            |m: &mut DepositRequest| { &mut m.depositor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deposit_coins",
            |m: &DepositRequest| { &m.deposit_coins },
            |m: &mut DepositRequest| { &mut m.deposit_coins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accepted_coins",
            |m: &DepositRequest| { &m.accepted_coins },
            |m: &mut DepositRequest| { &mut m.accepted_coins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "minted_pool_coin",
            |m: &DepositRequest| { &m.minted_pool_coin },
            |m: &mut DepositRequest| { &mut m.minted_pool_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &DepositRequest| { &m.status },
            |m: &mut DepositRequest| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DepositRequest>(
            "DepositRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DepositRequest {
    const NAME: &'static str = "DepositRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                16 => {
                    self.pool_id = is.read_uint64()?;
                },
                24 => {
                    self.msg_height = is.read_int64()?;
                },
                34 => {
                    self.depositor = is.read_string()?;
                },
                42 => {
                    self.deposit_coins.push(is.read_message()?);
                },
                50 => {
                    self.accepted_coins.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minted_pool_coin)?;
                },
                64 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.pool_id);
        }
        if self.msg_height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.msg_height);
        }
        if !self.depositor.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.depositor);
        }
        for value in &self.deposit_coins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accepted_coins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.minted_pool_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(8, self.status.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.pool_id != 0 {
            os.write_uint64(2, self.pool_id)?;
        }
        if self.msg_height != 0 {
            os.write_int64(3, self.msg_height)?;
        }
        if !self.depositor.is_empty() {
            os.write_string(4, &self.depositor)?;
        }
        for v in &self.deposit_coins {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.accepted_coins {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.minted_pool_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DepositRequest {
        DepositRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.pool_id = 0;
        self.msg_height = 0;
        self.depositor.clear();
        self.deposit_coins.clear();
        self.accepted_coins.clear();
        self.minted_pool_coin.clear();
        self.status = ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DepositRequest {
        static instance: DepositRequest = DepositRequest {
            id: 0,
            pool_id: 0,
            msg_height: 0,
            depositor: ::std::string::String::new(),
            deposit_coins: ::std::vec::Vec::new(),
            accepted_coins: ::std::vec::Vec::new(),
            minted_pool_coin: ::protobuf::MessageField::none(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DepositRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DepositRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DepositRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DepositRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  WithdrawRequest defines a withdraw request.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.WithdrawRequest)
pub struct WithdrawRequest {
    // message fields
    ///  id specifies the id for the request
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.id)
    pub id: u64,
    ///  pool_id specifies the pool id
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.pool_id)
    pub pool_id: u64,
    ///  msg_height specifies the block height when the request is stored for the batch execution
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.msg_height)
    pub msg_height: i64,
    ///  withdrawer specifies the bech32-encoded address that withdraws pool coin from the pool
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.withdrawer)
    pub withdrawer: ::std::string::String,
    ///  pool_coin specifies the pool coin that is a proof of liquidity provider for the pool
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.pool_coin)
    pub pool_coin: ::protobuf::MessageField<super::coin::Coin>,
    ///  withdrawn_coins specifies the amount of coins that are withdrawn.
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.withdrawn_coins)
    pub withdrawn_coins: ::std::vec::Vec<super::coin::Coin>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.WithdrawRequest.status)
    pub status: ::protobuf::EnumOrUnknown<RequestStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.WithdrawRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WithdrawRequest {
    fn default() -> &'a WithdrawRequest {
        <WithdrawRequest as ::protobuf::Message>::default_instance()
    }
}

impl WithdrawRequest {
    pub fn new() -> WithdrawRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WithdrawRequest| { &m.id },
            |m: &mut WithdrawRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_id",
            |m: &WithdrawRequest| { &m.pool_id },
            |m: &mut WithdrawRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_height",
            |m: &WithdrawRequest| { &m.msg_height },
            |m: &mut WithdrawRequest| { &mut m.msg_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "withdrawer",
            |m: &WithdrawRequest| { &m.withdrawer },
            |m: &mut WithdrawRequest| { &mut m.withdrawer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "pool_coin",
            |m: &WithdrawRequest| { &m.pool_coin },
            |m: &mut WithdrawRequest| { &mut m.pool_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "withdrawn_coins",
            |m: &WithdrawRequest| { &m.withdrawn_coins },
            |m: &mut WithdrawRequest| { &mut m.withdrawn_coins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &WithdrawRequest| { &m.status },
            |m: &mut WithdrawRequest| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WithdrawRequest>(
            "WithdrawRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WithdrawRequest {
    const NAME: &'static str = "WithdrawRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                16 => {
                    self.pool_id = is.read_uint64()?;
                },
                24 => {
                    self.msg_height = is.read_int64()?;
                },
                34 => {
                    self.withdrawer = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_coin)?;
                },
                50 => {
                    self.withdrawn_coins.push(is.read_message()?);
                },
                56 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if self.pool_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.pool_id);
        }
        if self.msg_height != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.msg_height);
        }
        if !self.withdrawer.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.withdrawer);
        }
        if let Some(v) = self.pool_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.withdrawn_coins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.status != ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(7, self.status.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.pool_id != 0 {
            os.write_uint64(2, self.pool_id)?;
        }
        if self.msg_height != 0 {
            os.write_int64(3, self.msg_height)?;
        }
        if !self.withdrawer.is_empty() {
            os.write_string(4, &self.withdrawer)?;
        }
        if let Some(v) = self.pool_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.withdrawn_coins {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.status != ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WithdrawRequest {
        WithdrawRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.pool_id = 0;
        self.msg_height = 0;
        self.withdrawer.clear();
        self.pool_coin.clear();
        self.withdrawn_coins.clear();
        self.status = ::protobuf::EnumOrUnknown::new(RequestStatus::REQUEST_STATUS_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WithdrawRequest {
        static instance: WithdrawRequest = WithdrawRequest {
            id: 0,
            pool_id: 0,
            msg_height: 0,
            withdrawer: ::std::string::String::new(),
            pool_coin: ::protobuf::MessageField::none(),
            withdrawn_coins: ::std::vec::Vec::new(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WithdrawRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WithdrawRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WithdrawRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WithdrawRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Order defines an order.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.Order)
pub struct Order {
    // message fields
    ///  type specifies the typo of the order
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.type)
    pub type_: ::protobuf::EnumOrUnknown<OrderType>,
    ///  id specifies the id of the order
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.id)
    pub id: u64,
    ///  pair_id specifies the pair id
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.pair_id)
    pub pair_id: u64,
    ///  msg_height specifies the block height when the order is stored for the batch execution
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.msg_height)
    pub msg_height: i64,
    ///  orderer specifies the bech32-encoded address that makes an order
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.orderer)
    pub orderer: ::std::string::String,
    ///  direction specifies the order direction; either buy or sell
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.direction)
    pub direction: ::protobuf::EnumOrUnknown<OrderDirection>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.offer_coin)
    pub offer_coin: ::protobuf::MessageField<super::coin::Coin>,
    ///  remaining_offer_coin specifies the remaining offer coin
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.remaining_offer_coin)
    pub remaining_offer_coin: ::protobuf::MessageField<super::coin::Coin>,
    ///  received_coin specifies the received coin after the swap
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.received_coin)
    pub received_coin: ::protobuf::MessageField<super::coin::Coin>,
    ///  price specifies the price that an orderer is willing to swap
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.amount)
    pub amount: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.open_amount)
    pub open_amount: ::std::string::String,
    ///  batch_id specifies the pair's batch id when the request is stored
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.batch_id)
    pub batch_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.expire_at)
    pub expire_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.Order.status)
    pub status: ::protobuf::EnumOrUnknown<OrderStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.Order.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Order {
    fn default() -> &'a Order {
        <Order as ::protobuf::Message>::default_instance()
    }
}

impl Order {
    pub fn new() -> Order {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Order| { &m.type_ },
            |m: &mut Order| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Order| { &m.id },
            |m: &mut Order| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &Order| { &m.pair_id },
            |m: &mut Order| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_height",
            |m: &Order| { &m.msg_height },
            |m: &mut Order| { &mut m.msg_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orderer",
            |m: &Order| { &m.orderer },
            |m: &mut Order| { &mut m.orderer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &Order| { &m.direction },
            |m: &mut Order| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "offer_coin",
            |m: &Order| { &m.offer_coin },
            |m: &mut Order| { &mut m.offer_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "remaining_offer_coin",
            |m: &Order| { &m.remaining_offer_coin },
            |m: &mut Order| { &mut m.remaining_offer_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::coin::Coin>(
            "received_coin",
            |m: &Order| { &m.received_coin },
            |m: &mut Order| { &mut m.received_coin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &Order| { &m.price },
            |m: &mut Order| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "amount",
            |m: &Order| { &m.amount },
            |m: &mut Order| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "open_amount",
            |m: &Order| { &m.open_amount },
            |m: &mut Order| { &mut m.open_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batch_id",
            |m: &Order| { &m.batch_id },
            |m: &mut Order| { &mut m.batch_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expire_at",
            |m: &Order| { &m.expire_at },
            |m: &mut Order| { &mut m.expire_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &Order| { &m.status },
            |m: &mut Order| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Order>(
            "Order",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Order {
    const NAME: &'static str = "Order";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.id = is.read_uint64()?;
                },
                24 => {
                    self.pair_id = is.read_uint64()?;
                },
                32 => {
                    self.msg_height = is.read_int64()?;
                },
                42 => {
                    self.orderer = is.read_string()?;
                },
                48 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.offer_coin)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.remaining_offer_coin)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.received_coin)?;
                },
                82 => {
                    self.price = is.read_string()?;
                },
                90 => {
                    self.amount = is.read_string()?;
                },
                98 => {
                    self.open_amount = is.read_string()?;
                },
                104 => {
                    self.batch_id = is.read_uint64()?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expire_at)?;
                },
                120 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(OrderType::ORDER_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.id);
        }
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.pair_id);
        }
        if self.msg_height != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.msg_height);
        }
        if !self.orderer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.orderer);
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(OrderDirection::ORDER_DIRECTION_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(6, self.direction.value());
        }
        if let Some(v) = self.offer_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remaining_offer_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.received_coin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.price);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.amount);
        }
        if !self.open_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.open_amount);
        }
        if self.batch_id != 0 {
            my_size += ::protobuf::rt::uint64_size(13, self.batch_id);
        }
        if let Some(v) = self.expire_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(OrderStatus::ORDER_STATUS_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(15, self.status.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(OrderType::ORDER_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if self.pair_id != 0 {
            os.write_uint64(3, self.pair_id)?;
        }
        if self.msg_height != 0 {
            os.write_int64(4, self.msg_height)?;
        }
        if !self.orderer.is_empty() {
            os.write_string(5, &self.orderer)?;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(OrderDirection::ORDER_DIRECTION_UNSPECIFIED) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if let Some(v) = self.offer_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.remaining_offer_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.received_coin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.price.is_empty() {
            os.write_string(10, &self.price)?;
        }
        if !self.amount.is_empty() {
            os.write_string(11, &self.amount)?;
        }
        if !self.open_amount.is_empty() {
            os.write_string(12, &self.open_amount)?;
        }
        if self.batch_id != 0 {
            os.write_uint64(13, self.batch_id)?;
        }
        if let Some(v) = self.expire_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(OrderStatus::ORDER_STATUS_UNSPECIFIED) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Order {
        Order::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(OrderType::ORDER_TYPE_UNSPECIFIED);
        self.id = 0;
        self.pair_id = 0;
        self.msg_height = 0;
        self.orderer.clear();
        self.direction = ::protobuf::EnumOrUnknown::new(OrderDirection::ORDER_DIRECTION_UNSPECIFIED);
        self.offer_coin.clear();
        self.remaining_offer_coin.clear();
        self.received_coin.clear();
        self.price.clear();
        self.amount.clear();
        self.open_amount.clear();
        self.batch_id = 0;
        self.expire_at.clear();
        self.status = ::protobuf::EnumOrUnknown::new(OrderStatus::ORDER_STATUS_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Order {
        static instance: Order = Order {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: 0,
            pair_id: 0,
            msg_height: 0,
            orderer: ::std::string::String::new(),
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            offer_coin: ::protobuf::MessageField::none(),
            remaining_offer_coin: ::protobuf::MessageField::none(),
            received_coin: ::protobuf::MessageField::none(),
            price: ::std::string::String::new(),
            amount: ::std::string::String::new(),
            open_amount: ::std::string::String::new(),
            batch_id: 0,
            expire_at: ::protobuf::MessageField::none(),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Order {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Order").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Order {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Order {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MMOrderIndex defines an index type to quickly find market making orders
///  from an orderer.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:shogun.liquidity.v1.MMOrderIndex)
pub struct MMOrderIndex {
    // message fields
    // @@protoc_insertion_point(field:shogun.liquidity.v1.MMOrderIndex.orderer)
    pub orderer: ::std::string::String,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.MMOrderIndex.pair_id)
    pub pair_id: u64,
    // @@protoc_insertion_point(field:shogun.liquidity.v1.MMOrderIndex.order_ids)
    pub order_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:shogun.liquidity.v1.MMOrderIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MMOrderIndex {
    fn default() -> &'a MMOrderIndex {
        <MMOrderIndex as ::protobuf::Message>::default_instance()
    }
}

impl MMOrderIndex {
    pub fn new() -> MMOrderIndex {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "orderer",
            |m: &MMOrderIndex| { &m.orderer },
            |m: &mut MMOrderIndex| { &mut m.orderer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pair_id",
            |m: &MMOrderIndex| { &m.pair_id },
            |m: &mut MMOrderIndex| { &mut m.pair_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "order_ids",
            |m: &MMOrderIndex| { &m.order_ids },
            |m: &mut MMOrderIndex| { &mut m.order_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MMOrderIndex>(
            "MMOrderIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MMOrderIndex {
    const NAME: &'static str = "MMOrderIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orderer = is.read_string()?;
                },
                16 => {
                    self.pair_id = is.read_uint64()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.order_ids)?;
                },
                24 => {
                    self.order_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.orderer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.orderer);
        }
        if self.pair_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.pair_id);
        }
        for value in &self.order_ids {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.orderer.is_empty() {
            os.write_string(1, &self.orderer)?;
        }
        if self.pair_id != 0 {
            os.write_uint64(2, self.pair_id)?;
        }
        for v in &self.order_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MMOrderIndex {
        MMOrderIndex::new()
    }

    fn clear(&mut self) {
        self.orderer.clear();
        self.pair_id = 0;
        self.order_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MMOrderIndex {
        static instance: MMOrderIndex = MMOrderIndex {
            orderer: ::std::string::String::new(),
            pair_id: 0,
            order_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MMOrderIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MMOrderIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MMOrderIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MMOrderIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  PoolType enumerates pool types.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:shogun.liquidity.v1.PoolType)
pub enum PoolType {
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.PoolType.POOL_TYPE_UNSPECIFIED)
    POOL_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.PoolType.POOL_TYPE_BASIC)
    POOL_TYPE_BASIC = 1,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.PoolType.POOL_TYPE_RANGED)
    POOL_TYPE_RANGED = 2,
}

impl ::protobuf::Enum for PoolType {
    const NAME: &'static str = "PoolType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PoolType> {
        match value {
            0 => ::std::option::Option::Some(PoolType::POOL_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(PoolType::POOL_TYPE_BASIC),
            2 => ::std::option::Option::Some(PoolType::POOL_TYPE_RANGED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PoolType] = &[
        PoolType::POOL_TYPE_UNSPECIFIED,
        PoolType::POOL_TYPE_BASIC,
        PoolType::POOL_TYPE_RANGED,
    ];
}

impl ::protobuf::EnumFull for PoolType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PoolType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PoolType {
    fn default() -> Self {
        PoolType::POOL_TYPE_UNSPECIFIED
    }
}

impl PoolType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PoolType>("PoolType")
    }
}

///  OrderType enumerates order types.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:shogun.liquidity.v1.OrderType)
pub enum OrderType {
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderType.ORDER_TYPE_UNSPECIFIED)
    ORDER_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderType.ORDER_TYPE_LIMIT)
    ORDER_TYPE_LIMIT = 1,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderType.ORDER_TYPE_MARKET)
    ORDER_TYPE_MARKET = 2,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderType.ORDER_TYPE_MM)
    ORDER_TYPE_MM = 3,
}

impl ::protobuf::Enum for OrderType {
    const NAME: &'static str = "OrderType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderType> {
        match value {
            0 => ::std::option::Option::Some(OrderType::ORDER_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(OrderType::ORDER_TYPE_LIMIT),
            2 => ::std::option::Option::Some(OrderType::ORDER_TYPE_MARKET),
            3 => ::std::option::Option::Some(OrderType::ORDER_TYPE_MM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrderType] = &[
        OrderType::ORDER_TYPE_UNSPECIFIED,
        OrderType::ORDER_TYPE_LIMIT,
        OrderType::ORDER_TYPE_MARKET,
        OrderType::ORDER_TYPE_MM,
    ];
}

impl ::protobuf::EnumFull for OrderType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrderType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrderType {
    fn default() -> Self {
        OrderType::ORDER_TYPE_UNSPECIFIED
    }
}

impl OrderType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderType>("OrderType")
    }
}

///  OrderDirection enumerates order directions.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:shogun.liquidity.v1.OrderDirection)
pub enum OrderDirection {
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderDirection.ORDER_DIRECTION_UNSPECIFIED)
    ORDER_DIRECTION_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderDirection.ORDER_DIRECTION_BUY)
    ORDER_DIRECTION_BUY = 1,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderDirection.ORDER_DIRECTION_SELL)
    ORDER_DIRECTION_SELL = 2,
}

impl ::protobuf::Enum for OrderDirection {
    const NAME: &'static str = "OrderDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderDirection> {
        match value {
            0 => ::std::option::Option::Some(OrderDirection::ORDER_DIRECTION_UNSPECIFIED),
            1 => ::std::option::Option::Some(OrderDirection::ORDER_DIRECTION_BUY),
            2 => ::std::option::Option::Some(OrderDirection::ORDER_DIRECTION_SELL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrderDirection] = &[
        OrderDirection::ORDER_DIRECTION_UNSPECIFIED,
        OrderDirection::ORDER_DIRECTION_BUY,
        OrderDirection::ORDER_DIRECTION_SELL,
    ];
}

impl ::protobuf::EnumFull for OrderDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrderDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrderDirection {
    fn default() -> Self {
        OrderDirection::ORDER_DIRECTION_UNSPECIFIED
    }
}

impl OrderDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderDirection>("OrderDirection")
    }
}

///  RequestStatus enumerates request statuses.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:shogun.liquidity.v1.RequestStatus)
pub enum RequestStatus {
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.RequestStatus.REQUEST_STATUS_UNSPECIFIED)
    REQUEST_STATUS_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.RequestStatus.REQUEST_STATUS_NOT_EXECUTED)
    REQUEST_STATUS_NOT_EXECUTED = 1,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.RequestStatus.REQUEST_STATUS_SUCCEEDED)
    REQUEST_STATUS_SUCCEEDED = 2,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.RequestStatus.REQUEST_STATUS_FAILED)
    REQUEST_STATUS_FAILED = 3,
}

impl ::protobuf::Enum for RequestStatus {
    const NAME: &'static str = "RequestStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestStatus> {
        match value {
            0 => ::std::option::Option::Some(RequestStatus::REQUEST_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(RequestStatus::REQUEST_STATUS_NOT_EXECUTED),
            2 => ::std::option::Option::Some(RequestStatus::REQUEST_STATUS_SUCCEEDED),
            3 => ::std::option::Option::Some(RequestStatus::REQUEST_STATUS_FAILED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RequestStatus] = &[
        RequestStatus::REQUEST_STATUS_UNSPECIFIED,
        RequestStatus::REQUEST_STATUS_NOT_EXECUTED,
        RequestStatus::REQUEST_STATUS_SUCCEEDED,
        RequestStatus::REQUEST_STATUS_FAILED,
    ];
}

impl ::protobuf::EnumFull for RequestStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RequestStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RequestStatus {
    fn default() -> Self {
        RequestStatus::REQUEST_STATUS_UNSPECIFIED
    }
}

impl RequestStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RequestStatus>("RequestStatus")
    }
}

///  OrderStatus enumerates order statuses.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:shogun.liquidity.v1.OrderStatus)
pub enum OrderStatus {
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_UNSPECIFIED)
    ORDER_STATUS_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_NOT_EXECUTED)
    ORDER_STATUS_NOT_EXECUTED = 1,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_NOT_MATCHED)
    ORDER_STATUS_NOT_MATCHED = 2,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_PARTIALLY_MATCHED)
    ORDER_STATUS_PARTIALLY_MATCHED = 3,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_COMPLETED)
    ORDER_STATUS_COMPLETED = 4,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_CANCELED)
    ORDER_STATUS_CANCELED = 5,
    // @@protoc_insertion_point(enum_value:shogun.liquidity.v1.OrderStatus.ORDER_STATUS_EXPIRED)
    ORDER_STATUS_EXPIRED = 6,
}

impl ::protobuf::Enum for OrderStatus {
    const NAME: &'static str = "OrderStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderStatus> {
        match value {
            0 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_NOT_EXECUTED),
            2 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_NOT_MATCHED),
            3 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_PARTIALLY_MATCHED),
            4 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_COMPLETED),
            5 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_CANCELED),
            6 => ::std::option::Option::Some(OrderStatus::ORDER_STATUS_EXPIRED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OrderStatus] = &[
        OrderStatus::ORDER_STATUS_UNSPECIFIED,
        OrderStatus::ORDER_STATUS_NOT_EXECUTED,
        OrderStatus::ORDER_STATUS_NOT_MATCHED,
        OrderStatus::ORDER_STATUS_PARTIALLY_MATCHED,
        OrderStatus::ORDER_STATUS_COMPLETED,
        OrderStatus::ORDER_STATUS_CANCELED,
        OrderStatus::ORDER_STATUS_EXPIRED,
    ];
}

impl ::protobuf::EnumFull for OrderStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OrderStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OrderStatus {
    fn default() -> Self {
        OrderStatus::ORDER_STATUS_UNSPECIFIED
    }
}

impl OrderStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderStatus>("OrderStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fliquidity.proto\x12\x13shogun.liquidity.v1\x1a\x1ecosmos/base/v1be\
    ta1/coin.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/prot\
    obuf/duration.proto\"\x9b\x07\n\x06Params\x12\x1d\n\nbatch_size\x18\x01\
    \x20\x01(\rR\tbatchSize\x12%\n\x0etick_precision\x18\x02\x20\x01(\rR\rti\
    ckPrecision\x122\n\x15fee_collector_address\x18\x03\x20\x01(\tR\x13feeCo\
    llectorAddress\x124\n\x16dust_collector_address\x18\x04\x20\x01(\tR\x14d\
    ustCollectorAddress\x12>\n\x1cmin_initial_pool_coin_supply\x18\x05\x20\
    \x01(\tR\x18minInitialPoolCoinSupply\x12E\n\x11pair_creation_fee\x18\x06\
    \x20\x03(\x0b2\x19.cosmos.base.v1beta1.CoinR\x0fpairCreationFee\x12E\n\
    \x11pool_creation_fee\x18\x07\x20\x03(\x0b2\x19.cosmos.base.v1beta1.Coin\
    R\x0fpoolCreationFee\x12;\n\x1amin_initial_deposit_amount\x18\x08\x20\
    \x01(\tR\x17minInitialDepositAmount\x121\n\x15max_price_limit_ratio\x18\
    \t\x20\x01(\tR\x12maxPriceLimitRatio\x12G\n!max_num_market_making_order_\
    ticks\x18\n\x20\x01(\rR\x1cmaxNumMarketMakingOrderTicks\x12G\n\x12max_or\
    der_lifespan\x18\x0b\x20\x01(\x0b2\x19.google.protobuf.DurationR\x10maxO\
    rderLifespan\x12\"\n\rswap_fee_rate\x18\x0c\x20\x01(\tR\x0bswapFeeRate\
    \x12*\n\x11withdraw_fee_rate\x18\r\x20\x01(\tR\x0fwithdrawFeeRate\x12*\n\
    \x11deposit_extra_gas\x18\x0e\x20\x01(\x04R\x0fdepositExtraGas\x12,\n\
    \x12withdraw_extra_gas\x18\x0f\x20\x01(\x04R\x10withdrawExtraGas\x12&\n\
    \x0forder_extra_gas\x18\x10\x20\x01(\x04R\rorderExtraGas\x12?\n\x1dmax_n\
    um_active_pools_per_pair\x18\x11\x20\x01(\rR\x18maxNumActivePoolsPerPair\
    \"\xfc\x01\n\x04Pair\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12&\n\
    \x0fbase_coin_denom\x18\x02\x20\x01(\tR\rbaseCoinDenom\x12(\n\x10quote_c\
    oin_denom\x18\x03\x20\x01(\tR\x0equoteCoinDenom\x12%\n\x0eescrow_address\
    \x18\x04\x20\x01(\tR\rescrowAddress\x12\"\n\rlast_order_id\x18\x05\x20\
    \x01(\x04R\x0blastOrderId\x12\x1d\n\nlast_price\x18\x06\x20\x01(\tR\tlas\
    tPrice\x12(\n\x10current_batch_id\x18\x07\x20\x01(\x04R\x0ecurrentBatchI\
    d\"\x93\x03\n\x04Pool\x121\n\x04type\x18\x01\x20\x01(\x0e2\x1d.shogun.li\
    quidity.v1.PoolTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\
    \x12\x17\n\x07pair_id\x18\x03\x20\x01(\x04R\x06pairId\x12\x18\n\x07creat\
    or\x18\x04\x20\x01(\tR\x07creator\x12'\n\x0freserve_address\x18\x05\x20\
    \x01(\tR\x0ereserveAddress\x12&\n\x0fpool_coin_denom\x18\x06\x20\x01(\tR\
    \rpoolCoinDenom\x12\x1b\n\tmin_price\x18\x07\x20\x01(\tR\x08minPrice\x12\
    \x1b\n\tmax_price\x18\x08\x20\x01(\tR\x08maxPrice\x125\n\x17last_deposit\
    _request_id\x18\t\x20\x01(\x04R\x14lastDepositRequestId\x127\n\x18last_w\
    ithdraw_request_id\x18\n\x20\x01(\x04R\x15lastWithdrawRequestId\x12\x1a\
    \n\x08disabled\x18\x0b\x20\x01(\x08R\x08disabled\"\xf9\x02\n\x0eDepositR\
    equest\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x17\n\x07pool_id\
    \x18\x02\x20\x01(\x04R\x06poolId\x12\x1d\n\nmsg_height\x18\x03\x20\x01(\
    \x03R\tmsgHeight\x12\x1c\n\tdepositor\x18\x04\x20\x01(\tR\tdepositor\x12\
    >\n\rdeposit_coins\x18\x05\x20\x03(\x0b2\x19.cosmos.base.v1beta1.CoinR\
    \x0cdepositCoins\x12@\n\x0eaccepted_coins\x18\x06\x20\x03(\x0b2\x19.cosm\
    os.base.v1beta1.CoinR\racceptedCoins\x12C\n\x10minted_pool_coin\x18\x07\
    \x20\x01(\x0b2\x19.cosmos.base.v1beta1.CoinR\x0emintedPoolCoin\x12:\n\
    \x06status\x18\x08\x20\x01(\x0e2\".shogun.liquidity.v1.RequestStatusR\
    \x06status\"\xb1\x02\n\x0fWithdrawRequest\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x04R\x02id\x12\x17\n\x07pool_id\x18\x02\x20\x01(\x04R\x06poolId\
    \x12\x1d\n\nmsg_height\x18\x03\x20\x01(\x03R\tmsgHeight\x12\x1e\n\nwithd\
    rawer\x18\x04\x20\x01(\tR\nwithdrawer\x126\n\tpool_coin\x18\x05\x20\x01(\
    \x0b2\x19.cosmos.base.v1beta1.CoinR\x08poolCoin\x12B\n\x0fwithdrawn_coin\
    s\x18\x06\x20\x03(\x0b2\x19.cosmos.base.v1beta1.CoinR\x0ewithdrawnCoins\
    \x12:\n\x06status\x18\x07\x20\x01(\x0e2\".shogun.liquidity.v1.RequestSta\
    tusR\x06status\"\x84\x05\n\x05Order\x122\n\x04type\x18\x01\x20\x01(\x0e2\
    \x1e.shogun.liquidity.v1.OrderTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\x04R\x02id\x12\x17\n\x07pair_id\x18\x03\x20\x01(\x04R\x06pairId\
    \x12\x1d\n\nmsg_height\x18\x04\x20\x01(\x03R\tmsgHeight\x12\x18\n\x07ord\
    erer\x18\x05\x20\x01(\tR\x07orderer\x12A\n\tdirection\x18\x06\x20\x01(\
    \x0e2#.shogun.liquidity.v1.OrderDirectionR\tdirection\x128\n\noffer_coin\
    \x18\x07\x20\x01(\x0b2\x19.cosmos.base.v1beta1.CoinR\tofferCoin\x12K\n\
    \x14remaining_offer_coin\x18\x08\x20\x01(\x0b2\x19.cosmos.base.v1beta1.C\
    oinR\x12remainingOfferCoin\x12>\n\rreceived_coin\x18\t\x20\x01(\x0b2\x19\
    .cosmos.base.v1beta1.CoinR\x0creceivedCoin\x12\x14\n\x05price\x18\n\x20\
    \x01(\tR\x05price\x12\x16\n\x06amount\x18\x0b\x20\x01(\tR\x06amount\x12\
    \x1f\n\x0bopen_amount\x18\x0c\x20\x01(\tR\nopenAmount\x12\x19\n\x08batch\
    _id\x18\r\x20\x01(\x04R\x07batchId\x127\n\texpire_at\x18\x0e\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x08expireAt\x128\n\x06status\x18\
    \x0f\x20\x01(\x0e2\x20.shogun.liquidity.v1.OrderStatusR\x06status\"^\n\
    \x0cMMOrderIndex\x12\x18\n\x07orderer\x18\x01\x20\x01(\tR\x07orderer\x12\
    \x17\n\x07pair_id\x18\x02\x20\x01(\x04R\x06pairId\x12\x1b\n\torder_ids\
    \x18\x03\x20\x03(\x04R\x08orderIds*P\n\x08PoolType\x12\x19\n\x15POOL_TYP\
    E_UNSPECIFIED\x10\0\x12\x13\n\x0fPOOL_TYPE_BASIC\x10\x01\x12\x14\n\x10PO\
    OL_TYPE_RANGED\x10\x02*g\n\tOrderType\x12\x1a\n\x16ORDER_TYPE_UNSPECIFIE\
    D\x10\0\x12\x14\n\x10ORDER_TYPE_LIMIT\x10\x01\x12\x15\n\x11ORDER_TYPE_MA\
    RKET\x10\x02\x12\x11\n\rORDER_TYPE_MM\x10\x03*d\n\x0eOrderDirection\x12\
    \x1f\n\x1bORDER_DIRECTION_UNSPECIFIED\x10\0\x12\x17\n\x13ORDER_DIRECTION\
    _BUY\x10\x01\x12\x18\n\x14ORDER_DIRECTION_SELL\x10\x02*\x89\x01\n\rReque\
    stStatus\x12\x1e\n\x1aREQUEST_STATUS_UNSPECIFIED\x10\0\x12\x1f\n\x1bREQU\
    EST_STATUS_NOT_EXECUTED\x10\x01\x12\x1c\n\x18REQUEST_STATUS_SUCCEEDED\
    \x10\x02\x12\x19\n\x15REQUEST_STATUS_FAILED\x10\x03*\xdd\x01\n\x0bOrderS\
    tatus\x12\x1c\n\x18ORDER_STATUS_UNSPECIFIED\x10\0\x12\x1d\n\x19ORDER_STA\
    TUS_NOT_EXECUTED\x10\x01\x12\x1c\n\x18ORDER_STATUS_NOT_MATCHED\x10\x02\
    \x12\"\n\x1eORDER_STATUS_PARTIALLY_MATCHED\x10\x03\x12\x1a\n\x16ORDER_ST\
    ATUS_COMPLETED\x10\x04\x12\x19\n\x15ORDER_STATUS_CANCELED\x10\x05\x12\
    \x18\n\x14ORDER_STATUS_EXPIRED\x10\x06J\xe3B\n\x07\x12\x05\0\0\x8c\x02\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x1c\n\
    \t\n\x02\x03\0\x12\x03\x03\0(\n\t\n\x02\x03\x01\x12\x03\x04\0)\n\t\n\x02\
    \x03\x02\x12\x03\x05\0(\nE\n\x02\x04\0\x12\x04\x08\0*\x01\x1a9\x20Params\
    \x20defines\x20the\x20parameters\x20for\x20the\x20liquidity\x20module.\n\
    \n\n\n\x03\x04\0\x01\x12\x03\x08\x08\x0e\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \t\x02\x18\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\t\x02\x08\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03\t\t\x13\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\t\x16\
    \x17\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x0b\x02\x1c\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03\x0b\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0b\t\
    \x17\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0b\x1a\x1b\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x03\r\x02#\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\r\x02\x08\
    \n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\r\t\x1e\n\x0c\n\x05\x04\0\x02\x02\
    \x03\x12\x03\r!\"\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x0f\x02$\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03\x0f\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\x0f\t\x1f\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f\"#\n\x0b\n\x04\
    \x04\0\x02\x04\x12\x03\x11\x02*\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\
    \x11\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x11\t%\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x03\x11()\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x13\
    \x02:\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x13\x02\n\n\x0c\n\x05\x04\0\
    \x02\x05\x06\x12\x03\x13\x0b#\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x13$\
    5\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x1389\n\x0b\n\x04\x04\0\x02\x06\
    \x12\x03\x15\x02:\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x15\x02\n\n\x0c\
    \n\x05\x04\0\x02\x06\x06\x12\x03\x15\x0b#\n\x0c\n\x05\x04\0\x02\x06\x01\
    \x12\x03\x15$5\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1589\n\x0b\n\x04\
    \x04\0\x02\x07\x12\x03\x17\x02(\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\
    \x17\x02\x08\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x17\t#\n\x0c\n\x05\
    \x04\0\x02\x07\x03\x12\x03\x17&'\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x19\
    \x02#\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03\x19\x02\x08\n\x0c\n\x05\x04\
    \0\x02\x08\x01\x12\x03\x19\t\x1e\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\
    \x19!\"\n\x0b\n\x04\x04\0\x02\t\x12\x03\x1b\x020\n\x0c\n\x05\x04\0\x02\t\
    \x05\x12\x03\x1b\x02\x08\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x1b\t*\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x03\x1b-/\n\x0b\n\x04\x04\0\x02\n\x12\x03\
    \x1d\x024\n\x0c\n\x05\x04\0\x02\n\x06\x12\x03\x1d\x02\x1a\n\x0c\n\x05\
    \x04\0\x02\n\x01\x12\x03\x1d\x1b-\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03\
    \x1d02\n\x0b\n\x04\x04\0\x02\x0b\x12\x03\x1f\x02\x1c\n\x0c\n\x05\x04\0\
    \x02\x0b\x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\0\x02\x0b\x01\x12\x03\
    \x1f\t\x16\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03\x1f\x19\x1b\n\x0b\n\x04\
    \x04\0\x02\x0c\x12\x03!\x02\x20\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03!\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x0c\x01\x12\x03!\t\x1a\n\x0c\n\x05\x04\0\
    \x02\x0c\x03\x12\x03!\x1d\x1f\n\x0b\n\x04\x04\0\x02\r\x12\x03#\x02\x20\n\
    \x0c\n\x05\x04\0\x02\r\x05\x12\x03#\x02\x08\n\x0c\n\x05\x04\0\x02\r\x01\
    \x12\x03#\t\x1a\n\x0c\n\x05\x04\0\x02\r\x03\x12\x03#\x1d\x1f\n\x0b\n\x04\
    \x04\0\x02\x0e\x12\x03%\x02!\n\x0c\n\x05\x04\0\x02\x0e\x05\x12\x03%\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03%\t\x1b\n\x0c\n\x05\x04\0\x02\
    \x0e\x03\x12\x03%\x1e\x20\n\x0b\n\x04\x04\0\x02\x0f\x12\x03'\x02\x1e\n\
    \x0c\n\x05\x04\0\x02\x0f\x05\x12\x03'\x02\x08\n\x0c\n\x05\x04\0\x02\x0f\
    \x01\x12\x03'\t\x18\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03'\x1b\x1d\n\x0b\
    \n\x04\x04\0\x02\x10\x12\x03)\x02,\n\x0c\n\x05\x04\0\x02\x10\x05\x12\x03\
    )\x02\x08\n\x0c\n\x05\x04\0\x02\x10\x01\x12\x03)\t&\n\x0c\n\x05\x04\0\
    \x02\x10\x03\x12\x03))+\n'\n\x02\x04\x01\x12\x04-\0;\x01\x1a\x1b\x20Pair\
    \x20defines\x20a\x20coin\x20pair.\n\n\n\n\x03\x04\x01\x01\x12\x03-\x08\
    \x0c\n\x0b\n\x04\x04\x01\x02\0\x12\x03.\x02\x10\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x03.\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03.\t\x0b\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03.\x0e\x0f\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x030\x02\x1d\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x030\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x030\t\x18\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x030\x1b\x1c\n\x0b\n\x04\x04\x01\x02\x02\x12\x032\x02\x1e\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x032\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x032\t\x19\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x032\x1c\x1d\
    \n\x0b\n\x04\x04\x01\x02\x03\x12\x034\x02\x1c\n\x0c\n\x05\x04\x01\x02\
    \x03\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x034\t\x17\
    \n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x034\x1a\x1b\n\x0b\n\x04\x04\x01\
    \x02\x04\x12\x036\x02\x1b\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x036\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x036\t\x16\n\x0c\n\x05\x04\x01\
    \x02\x04\x03\x12\x036\x19\x1a\n\x0b\n\x04\x04\x01\x02\x05\x12\x038\x02\
    \x18\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\x05\x01\x12\x038\t\x13\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x038\
    \x16\x17\n\x0b\n\x04\x04\x01\x02\x06\x12\x03:\x02\x1e\n\x0c\n\x05\x04\
    \x01\x02\x06\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\
    \x03:\t\x19\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03:\x1c\x1d\nl\n\x02\
    \x04\x02\x12\x04?\0U\x01\x1a`\x20Pool\x20defines\x20generic\x20liquidity\
    \x20pool\x20object\x20which\x20can\x20be\x20either\x20a\x20basic\x20pool\
    \x20or\x20a\n\x20ranged\x20pool.\n\n\n\n\x03\x04\x02\x01\x12\x03?\x08\
    \x0c\n\x0b\n\x04\x04\x02\x02\0\x12\x03@\x02\x14\n\x0c\n\x05\x04\x02\x02\
    \0\x06\x12\x03@\x02\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03@\x0b\x0f\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03@\x12\x13\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03B\x02\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03B\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03B\t\x0b\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03B\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x02\x12\x03D\x02\x15\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03D\t\x10\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03D\x13\x14\
    \n\x0b\n\x04\x04\x02\x02\x03\x12\x03F\x02\x15\n\x0c\n\x05\x04\x02\x02\
    \x03\x05\x12\x03F\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03F\t\x10\
    \n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03F\x13\x14\n\x0b\n\x04\x04\x02\
    \x02\x04\x12\x03H\x02\x1d\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03H\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03H\t\x18\n\x0c\n\x05\x04\x02\
    \x02\x04\x03\x12\x03H\x1b\x1c\n\x0b\n\x04\x04\x02\x02\x05\x12\x03J\x02\
    \x1d\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\
    \x02\x02\x05\x01\x12\x03J\t\x18\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03J\
    \x1b\x1c\n\x0b\n\x04\x04\x02\x02\x06\x12\x03L\x02\x17\n\x0c\n\x05\x04\
    \x02\x02\x06\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\
    \x03L\t\x12\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03L\x15\x16\n\x0b\n\x04\
    \x04\x02\x02\x07\x12\x03N\x02\x17\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\
    \x03N\x02\x08\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03N\t\x12\n\x0c\n\x05\
    \x04\x02\x02\x07\x03\x12\x03N\x15\x16\n\x0b\n\x04\x04\x02\x02\x08\x12\
    \x03P\x02%\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03P\x02\x08\n\x0c\n\x05\
    \x04\x02\x02\x08\x01\x12\x03P\t\x20\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\
    \x03P#$\n\x0b\n\x04\x04\x02\x02\t\x12\x03R\x02'\n\x0c\n\x05\x04\x02\x02\
    \t\x05\x12\x03R\x02\x08\n\x0c\n\x05\x04\x02\x02\t\x01\x12\x03R\t!\n\x0c\
    \n\x05\x04\x02\x02\t\x03\x12\x03R$&\n\x0b\n\x04\x04\x02\x02\n\x12\x03T\
    \x02\x15\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03T\x02\x06\n\x0c\n\x05\x04\
    \x02\x02\n\x01\x12\x03T\x07\x0f\n\x0c\n\x05\x04\x02\x02\n\x03\x12\x03T\
    \x12\x14\n7\n\x02\x04\x03\x12\x04X\0p\x01\x1a+\x20DepositRequest\x20defi\
    nes\x20a\x20deposit\x20request.\n\n\n\n\x03\x04\x03\x01\x12\x03X\x08\x16\
    \n2\n\x04\x04\x03\x02\0\x12\x03Z\x02\x10\x1a%\x20id\x20specifies\x20the\
    \x20id\x20for\x20the\x20request\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03Z\
    \x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03Z\t\x0b\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03Z\x0e\x0f\n,\n\x04\x04\x03\x02\x01\x12\x03]\x02\
    \x15\x1a\x1f\x20pool_id\x20specifies\x20the\x20pool\x20id\n\n\x0c\n\x05\
    \x04\x03\x02\x01\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\
    \x12\x03]\t\x10\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03]\x13\x14\ng\n\
    \x04\x04\x03\x02\x02\x12\x03`\x02\x17\x1aZ\x20msg_height\x20specifies\
    \x20the\x20block\x20height\x20when\x20the\x20request\x20is\x20stored\x20\
    for\x20the\x20batch\x20execution\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03`\x02\x07\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03`\x08\x12\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x03`\x15\x16\n^\n\x04\x04\x03\x02\x03\x12\
    \x03c\x02\x17\x1aQ\x20depositor\x20specifies\x20the\x20bech32-encoded\
    \x20address\x20that\x20makes\x20a\x20deposit\x20to\x20the\x20pool\n\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03c\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03c\t\x12\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03c\x15\x16\
    \nG\n\x04\x04\x03\x02\x04\x12\x04f\x02g\x07\x1a9\x20deposit_coins\x20spe\
    cifies\x20the\x20amount\x20of\x20coins\x20to\x20deposit.\n\n\x0c\n\x05\
    \x04\x03\x02\x04\x04\x12\x03f\x02\n\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\
    \x03f\x0b#\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03f$1\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03f45\nO\n\x04\x04\x03\x02\x05\x12\x04j\x02k\x07\
    \x1aA\x20accepted_coins\x20specifies\x20the\x20amount\x20of\x20coins\x20\
    that\x20are\x20accepted.\n\n\x0c\n\x05\x04\x03\x02\x05\x04\x12\x03j\x02\
    \n\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03j\x0b#\n\x0c\n\x05\x04\x03\x02\
    \x05\x01\x12\x03j$2\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x03j56\n\x0b\n\
    \x04\x04\x03\x02\x06\x12\x03m\x021\n\x0c\n\x05\x04\x03\x02\x06\x06\x12\
    \x03m\x02\x1a\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03m\x1b+\n\x0c\n\x05\
    \x04\x03\x02\x06\x03\x12\x03m./\n\x0b\n\x04\x04\x03\x02\x07\x12\x03o\x02\
    \x1b\n\x0c\n\x05\x04\x03\x02\x07\x06\x12\x03o\x02\x0f\n\x0c\n\x05\x04\
    \x03\x02\x07\x01\x12\x03o\x10\x16\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\
    \x03o\x19\x1a\n:\n\x02\x04\x04\x12\x05s\0\x88\x01\x01\x1a-\x20WithdrawRe\
    quest\x20defines\x20a\x20withdraw\x20request.\n\n\n\n\x03\x04\x04\x01\
    \x12\x03s\x08\x17\n2\n\x04\x04\x04\x02\0\x12\x03u\x02\x10\x1a%\x20id\x20\
    specifies\x20the\x20id\x20for\x20the\x20request\n\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03u\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03u\t\x0b\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03u\x0e\x0f\n,\n\x04\x04\x04\x02\x01\
    \x12\x03x\x02\x15\x1a\x1f\x20pool_id\x20specifies\x20the\x20pool\x20id\n\
    \n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03x\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\x01\x01\x12\x03x\t\x10\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03x\x13\
    \x14\ng\n\x04\x04\x04\x02\x02\x12\x03{\x02\x17\x1aZ\x20msg_height\x20spe\
    cifies\x20the\x20block\x20height\x20when\x20the\x20request\x20is\x20stor\
    ed\x20for\x20the\x20batch\x20execution\n\n\x0c\n\x05\x04\x04\x02\x02\x05\
    \x12\x03{\x02\x07\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03{\x08\x12\n\x0c\
    \n\x05\x04\x04\x02\x02\x03\x12\x03{\x15\x16\ne\n\x04\x04\x04\x02\x03\x12\
    \x03~\x02\x18\x1aX\x20withdrawer\x20specifies\x20the\x20bech32-encoded\
    \x20address\x20that\x20withdraws\x20pool\x20coin\x20from\x20the\x20pool\
    \n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03~\x02\x08\n\x0c\n\x05\x04\x04\
    \x02\x03\x01\x12\x03~\t\x13\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03~\x16\
    \x17\nd\n\x04\x04\x04\x02\x04\x12\x04\x81\x01\x02*\x1aV\x20pool_coin\x20\
    specifies\x20the\x20pool\x20coin\x20that\x20is\x20a\x20proof\x20of\x20li\
    quidity\x20provider\x20for\x20the\x20pool\n\n\r\n\x05\x04\x04\x02\x04\
    \x06\x12\x04\x81\x01\x02\x1a\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\x81\
    \x01\x1b$\n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\x81\x01'(\nS\n\x04\x04\
    \x04\x02\x05\x12\x06\x84\x01\x02\x85\x01\x07\x1aC\x20withdrawn_coins\x20\
    specifies\x20the\x20amount\x20of\x20coins\x20that\x20are\x20withdrawn.\n\
    \n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\x84\x01\x02\n\n\r\n\x05\x04\x04\
    \x02\x05\x06\x12\x04\x84\x01\x0b#\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\
    \x84\x01$3\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\x84\x0167\n\x0c\n\x04\
    \x04\x04\x02\x06\x12\x04\x87\x01\x02\x1b\n\r\n\x05\x04\x04\x02\x06\x06\
    \x12\x04\x87\x01\x02\x0f\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\x87\x01\
    \x10\x16\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\x87\x01\x19\x1a\n'\n\x02\
    \x04\x05\x12\x06\x8b\x01\0\xb4\x01\x01\x1a\x19\x20Order\x20defines\x20an\
    \x20order.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x8b\x01\x08\r\n4\n\x04\x04\
    \x05\x02\0\x12\x04\x8d\x01\x02\x15\x1a&\x20type\x20specifies\x20the\x20t\
    ypo\x20of\x20the\x20order\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x8d\x01\
    \x02\x0b\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x8d\x01\x0c\x10\n\r\n\x05\
    \x04\x05\x02\0\x03\x12\x04\x8d\x01\x13\x14\n0\n\x04\x04\x05\x02\x01\x12\
    \x04\x90\x01\x02\x10\x1a\"\x20id\x20specifies\x20the\x20id\x20of\x20the\
    \x20order\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x90\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\x90\x01\t\x0b\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\x90\x01\x0e\x0f\n-\n\x04\x04\x05\x02\x02\x12\x04\x93\x01\
    \x02\x15\x1a\x1f\x20pair_id\x20specifies\x20the\x20pair\x20id\n\n\r\n\
    \x05\x04\x05\x02\x02\x05\x12\x04\x93\x01\x02\x08\n\r\n\x05\x04\x05\x02\
    \x02\x01\x12\x04\x93\x01\t\x10\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x93\
    \x01\x13\x14\nf\n\x04\x04\x05\x02\x03\x12\x04\x96\x01\x02\x17\x1aX\x20ms\
    g_height\x20specifies\x20the\x20block\x20height\x20when\x20the\x20order\
    \x20is\x20stored\x20for\x20the\x20batch\x20execution\n\n\r\n\x05\x04\x05\
    \x02\x03\x05\x12\x04\x96\x01\x02\x07\n\r\n\x05\x04\x05\x02\x03\x01\x12\
    \x04\x96\x01\x08\x12\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x96\x01\x15\
    \x16\nP\n\x04\x04\x05\x02\x04\x12\x04\x99\x01\x02\x15\x1aB\x20orderer\
    \x20specifies\x20the\x20bech32-encoded\x20address\x20that\x20makes\x20an\
    \x20order\n\n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\x99\x01\x02\x08\n\r\n\
    \x05\x04\x05\x02\x04\x01\x12\x04\x99\x01\t\x10\n\r\n\x05\x04\x05\x02\x04\
    \x03\x12\x04\x99\x01\x13\x14\nK\n\x04\x04\x05\x02\x05\x12\x04\x9c\x01\
    \x02\x1f\x1a=\x20direction\x20specifies\x20the\x20order\x20direction;\
    \x20either\x20buy\x20or\x20sell\n\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\
    \x9c\x01\x02\x10\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\x9c\x01\x11\x1a\n\
    \r\n\x05\x04\x05\x02\x05\x03\x12\x04\x9c\x01\x1d\x1e\n\x0c\n\x04\x04\x05\
    \x02\x06\x12\x04\x9e\x01\x02+\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x9e\
    \x01\x02\x1a\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\x9e\x01\x1b%\n\r\n\
    \x05\x04\x05\x02\x06\x03\x12\x04\x9e\x01()\nG\n\x04\x04\x05\x02\x07\x12\
    \x04\xa1\x01\x025\x1a9\x20remaining_offer_coin\x20specifies\x20the\x20re\
    maining\x20offer\x20coin\n\n\r\n\x05\x04\x05\x02\x07\x06\x12\x04\xa1\x01\
    \x02\x1a\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\xa1\x01\x1b/\n\r\n\x05\
    \x04\x05\x02\x07\x03\x12\x04\xa1\x0123\nH\n\x04\x04\x05\x02\x08\x12\x04\
    \xa4\x01\x02.\x1a:\x20received_coin\x20specifies\x20the\x20received\x20c\
    oin\x20after\x20the\x20swap\n\n\r\n\x05\x04\x05\x02\x08\x06\x12\x04\xa4\
    \x01\x02\x1a\n\r\n\x05\x04\x05\x02\x08\x01\x12\x04\xa4\x01\x1b(\n\r\n\
    \x05\x04\x05\x02\x08\x03\x12\x04\xa4\x01+,\nL\n\x04\x04\x05\x02\t\x12\
    \x04\xa7\x01\x02\x15\x1a>\x20price\x20specifies\x20the\x20price\x20that\
    \x20an\x20orderer\x20is\x20willing\x20to\x20swap\n\n\r\n\x05\x04\x05\x02\
    \t\x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x05\x02\t\x01\x12\x04\xa7\
    \x01\t\x0e\n\r\n\x05\x04\x05\x02\t\x03\x12\x04\xa7\x01\x11\x13\n\x0c\n\
    \x04\x04\x05\x02\n\x12\x04\xa9\x01\x02\x16\n\r\n\x05\x04\x05\x02\n\x05\
    \x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x05\x02\n\x01\x12\x04\xa9\x01\t\
    \x0f\n\r\n\x05\x04\x05\x02\n\x03\x12\x04\xa9\x01\x12\x14\n\x0e\n\x04\x04\
    \x05\x02\x0b\x12\x06\xab\x01\x02\xac\x01\x07\n\r\n\x05\x04\x05\x02\x0b\
    \x05\x12\x04\xab\x01\x02\x08\n\r\n\x05\x04\x05\x02\x0b\x01\x12\x04\xab\
    \x01\t\x14\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\xab\x01\x17\x19\nQ\n\
    \x04\x04\x05\x02\x0c\x12\x04\xaf\x01\x02\x17\x1aC\x20batch_id\x20specifi\
    es\x20the\x20pair's\x20batch\x20id\x20when\x20the\x20request\x20is\x20st\
    ored\n\n\r\n\x05\x04\x05\x02\x0c\x05\x12\x04\xaf\x01\x02\x08\n\r\n\x05\
    \x04\x05\x02\x0c\x01\x12\x04\xaf\x01\t\x11\n\r\n\x05\x04\x05\x02\x0c\x03\
    \x12\x04\xaf\x01\x14\x16\n\x0c\n\x04\x04\x05\x02\r\x12\x04\xb1\x01\x02,\
    \n\r\n\x05\x04\x05\x02\r\x06\x12\x04\xb1\x01\x02\x1b\n\r\n\x05\x04\x05\
    \x02\r\x01\x12\x04\xb1\x01\x1c%\n\r\n\x05\x04\x05\x02\r\x03\x12\x04\xb1\
    \x01(*\n\x0c\n\x04\x04\x05\x02\x0e\x12\x04\xb3\x01\x02\x1a\n\r\n\x05\x04\
    \x05\x02\x0e\x06\x12\x04\xb3\x01\x02\r\n\r\n\x05\x04\x05\x02\x0e\x01\x12\
    \x04\xb3\x01\x0e\x14\n\r\n\x05\x04\x05\x02\x0e\x03\x12\x04\xb3\x01\x17\
    \x19\ni\n\x02\x04\x06\x12\x06\xb8\x01\0\xbe\x01\x01\x1a[\x20MMOrderIndex\
    \x20defines\x20an\x20index\x20type\x20to\x20quickly\x20find\x20market\
    \x20making\x20orders\n\x20from\x20an\x20orderer.\n\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\xb8\x01\x08\x14\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xb9\x01\
    \x02\x15\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xb9\x01\x02\x08\n\r\n\x05\
    \x04\x06\x02\0\x01\x12\x04\xb9\x01\t\x10\n\r\n\x05\x04\x06\x02\0\x03\x12\
    \x04\xb9\x01\x13\x14\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xbb\x01\x02\x15\
    \n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\xbb\x01\x02\x08\n\r\n\x05\x04\x06\
    \x02\x01\x01\x12\x04\xbb\x01\t\x10\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\
    \xbb\x01\x13\x14\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xbd\x01\x02\x20\n\r\
    \n\x05\x04\x06\x02\x02\x04\x12\x04\xbd\x01\x02\n\n\r\n\x05\x04\x06\x02\
    \x02\x05\x12\x04\xbd\x01\x0b\x11\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\
    \xbd\x01\x12\x1b\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xbd\x01\x1e\x1f\n\
    /\n\x02\x05\0\x12\x06\xc1\x01\0\xca\x01\x01\x1a!\x20PoolType\x20enumerat\
    es\x20pool\x20types.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xc1\x01\x05\r\nA\n\
    \x04\x05\0\x02\0\x12\x04\xc3\x01\x02\x1d\x1a3\x20POOL_TYPE_UNSPECIFIED\
    \x20specifies\x20unknown\x20pool\x20type\n\n\r\n\x05\x05\0\x02\0\x01\x12\
    \x04\xc3\x01\x02\x17\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xc3\x01\x1a\x1b\n\
    =\n\x04\x05\0\x02\x01\x12\x04\xc6\x01\x02\x17\x1a/\x20POOL_TYPE_BASIC\
    \x20specifies\x20the\x20basic\x20pool\x20type\n\n\r\n\x05\x05\0\x02\x01\
    \x01\x12\x04\xc6\x01\x02\x11\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xc6\x01\
    \x14\x15\n?\n\x04\x05\0\x02\x02\x12\x04\xc9\x01\x02\x18\x1a1\x20POOL_TYP\
    E_RANGED\x20specifies\x20the\x20ranged\x20pool\x20type\n\n\r\n\x05\x05\0\
    \x02\x02\x01\x12\x04\xc9\x01\x02\x12\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\
    \xc9\x01\x15\x16\n1\n\x02\x05\x01\x12\x06\xcd\x01\0\xd9\x01\x01\x1a#\x20\
    OrderType\x20enumerates\x20order\x20types.\n\n\x0b\n\x03\x05\x01\x01\x12\
    \x04\xcd\x01\x05\x0e\nD\n\x04\x05\x01\x02\0\x12\x04\xcf\x01\x02\x1e\x1a6\
    \x20ORDER_TYPE_UNSPECIFIED\x20specifies\x20unknown\x20order\x20type.\n\n\
    \r\n\x05\x05\x01\x02\0\x01\x12\x04\xcf\x01\x02\x18\n\r\n\x05\x05\x01\x02\
    \0\x02\x12\x04\xcf\x01\x1b\x1c\n<\n\x04\x05\x01\x02\x01\x12\x04\xd2\x01\
    \x02\x18\x1a.\x20ORDER_TYPE_LIMIT\x20specifies\x20limit\x20order\x20type\
    .\n\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xd2\x01\x02\x12\n\r\n\x05\x05\
    \x01\x02\x01\x02\x12\x04\xd2\x01\x15\x16\n>\n\x04\x05\x01\x02\x02\x12\
    \x04\xd5\x01\x02\x19\x1a0\x20ORDER_TYPE_MARKET\x20specifies\x20market\
    \x20order\x20type.\n\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xd5\x01\x02\
    \x13\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xd5\x01\x16\x17\nE\n\x04\x05\
    \x01\x02\x03\x12\x04\xd8\x01\x02\x15\x1a7\x20ORDER_TYPE_MM\x20specifies\
    \x20MM(market\x20making)\x20order\x20type.\n\n\r\n\x05\x05\x01\x02\x03\
    \x01\x12\x04\xd8\x01\x02\x0f\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\xd8\
    \x01\x12\x13\n;\n\x02\x05\x02\x12\x06\xdc\x01\0\xe5\x01\x01\x1a-\x20Orde\
    rDirection\x20enumerates\x20order\x20directions.\n\n\x0b\n\x03\x05\x02\
    \x01\x12\x04\xdc\x01\x05\x13\nM\n\x04\x05\x02\x02\0\x12\x04\xde\x01\x02#\
    \x1a?\x20ORDER_DIRECTION_UNSPECIFIED\x20specifies\x20unknown\x20order\
    \x20direction\n\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xde\x01\x02\x1d\n\r\
    \n\x05\x05\x02\x02\0\x02\x12\x04\xde\x01\x20!\n_\n\x04\x05\x02\x02\x01\
    \x12\x04\xe1\x01\x02\x1b\x1aQ\x20ORDER_DIRECTION_BUY\x20specifies\x20buy\
    (swap\x20quote\x20coin\x20to\x20base\x20coin)\x20order\x20direction\n\n\
    \r\n\x05\x05\x02\x02\x01\x01\x12\x04\xe1\x01\x02\x15\n\r\n\x05\x05\x02\
    \x02\x01\x02\x12\x04\xe1\x01\x18\x19\na\n\x04\x05\x02\x02\x02\x12\x04\
    \xe4\x01\x02\x1c\x1aS\x20ORDER_DIRECTION_SELL\x20specifies\x20sell(swap\
    \x20base\x20coin\x20to\x20quote\x20coin)\x20order\x20direction\n\n\r\n\
    \x05\x05\x02\x02\x02\x01\x12\x04\xe4\x01\x02\x16\n\r\n\x05\x05\x02\x02\
    \x02\x02\x12\x04\xe4\x01\x19\x1a\n:\n\x02\x05\x03\x12\x06\xe8\x01\0\xf4\
    \x01\x01\x1a,\x20RequestStatus\x20enumerates\x20request\x20statuses.\n\n\
    \x0b\n\x03\x05\x03\x01\x12\x04\xe8\x01\x05\x12\nK\n\x04\x05\x03\x02\0\
    \x12\x04\xea\x01\x02\"\x1a=\x20REQUEST_STATUS_UNSPECIFIED\x20specifies\
    \x20unknown\x20request\x20status\n\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\
    \xea\x01\x02\x1c\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xea\x01\x1f\x20\nU\
    \n\x04\x05\x03\x02\x01\x12\x04\xed\x01\x02#\x1aG\x20REQUEST_STATUS_NOT_E\
    XECUTED\x20indicates\x20the\x20request\x20is\x20not\x20executed\x20yet\n\
    \n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xed\x01\x02\x1d\n\r\n\x05\x05\x03\
    \x02\x01\x02\x12\x04\xed\x01\x20!\nQ\n\x04\x05\x03\x02\x02\x12\x04\xf0\
    \x01\x02\x20\x1aC\x20REQUEST_STATUS_SUCCEEDED\x20indicates\x20the\x20req\
    uest\x20has\x20been\x20succeeded\n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\
    \xf0\x01\x02\x1a\n\r\n\x05\x05\x03\x02\x02\x02\x12\x04\xf0\x01\x1d\x1e\n\
    E\n\x04\x05\x03\x02\x03\x12\x04\xf3\x01\x02\x1d\x1a7\x20REQUEST_STATUS_F\
    AILED\x20indicates\x20the\x20request\x20is\x20failed\n\n\r\n\x05\x05\x03\
    \x02\x03\x01\x12\x04\xf3\x01\x02\x17\n\r\n\x05\x05\x03\x02\x03\x02\x12\
    \x04\xf3\x01\x1a\x1b\n6\n\x02\x05\x04\x12\x06\xf7\x01\0\x8c\x02\x01\x1a(\
    \x20OrderStatus\x20enumerates\x20order\x20statuses.\n\n\x0b\n\x03\x05\
    \x04\x01\x12\x04\xf7\x01\x05\x10\nG\n\x04\x05\x04\x02\0\x12\x04\xf9\x01\
    \x02\x20\x1a9\x20ORDER_STATUS_UNSPECIFIED\x20specifies\x20unknown\x20ord\
    er\x20status\n\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xf9\x01\x02\x1a\n\r\n\
    \x05\x05\x04\x02\0\x02\x12\x04\xf9\x01\x1d\x1e\nW\n\x04\x05\x04\x02\x01\
    \x12\x04\xfc\x01\x02!\x1aI\x20ORDER_STATUS_NOT_EXECUTED\x20indicates\x20\
    the\x20order\x20has\x20not\x20been\x20executed\x20yet\n\n\r\n\x05\x05\
    \x04\x02\x01\x01\x12\x04\xfc\x01\x02\x1b\n\r\n\x05\x05\x04\x02\x01\x02\
    \x12\x04\xfc\x01\x1e\x1f\n_\n\x04\x05\x04\x02\x02\x12\x04\xff\x01\x02\
    \x20\x1aQ\x20ORDER_STATUS_NOT_MATCHED\x20indicates\x20the\x20order\x20ha\
    s\x20been\x20executed\x20but\x20has\x20no\x20match\n\n\r\n\x05\x05\x04\
    \x02\x02\x01\x12\x04\xff\x01\x02\x1a\n\r\n\x05\x05\x04\x02\x02\x02\x12\
    \x04\xff\x01\x1d\x1e\n]\n\x04\x05\x04\x02\x03\x12\x04\x82\x02\x02&\x1aO\
    \x20ORDER_STATUS_PARTIALLY_MATCHED\x20indicates\x20the\x20order\x20has\
    \x20been\x20partially\x20matched\n\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\
    \x82\x02\x02\x20\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\x82\x02#$\n_\n\
    \x04\x05\x04\x02\x04\x12\x04\x85\x02\x02\x1e\x1aQ\x20ORDER_STATUS_COMPLE\
    TED\x20indicates\x20the\x20order\x20has\x20been\x20fully\x20matched\x20a\
    nd\x20completed\n\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\x85\x02\x02\x18\
    \n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\x85\x02\x1b\x1c\nK\n\x04\x05\x04\
    \x02\x05\x12\x04\x88\x02\x02\x1d\x1a=\x20ORDER_STATUS_CANCELED\x20indica\
    tes\x20the\x20order\x20has\x20been\x20canceled\n\n\r\n\x05\x05\x04\x02\
    \x05\x01\x12\x04\x88\x02\x02\x17\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\
    \x88\x02\x1a\x1b\nI\n\x04\x05\x04\x02\x06\x12\x04\x8b\x02\x02\x1c\x1a;\
    \x20ORDER_STATUS_EXPIRED\x20indicates\x20the\x20order\x20has\x20been\x20\
    expired\n\n\r\n\x05\x05\x04\x02\x06\x01\x12\x04\x8b\x02\x02\x16\n\r\n\
    \x05\x05\x04\x02\x06\x02\x12\x04\x8b\x02\x19\x1ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::coin::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(Params::generated_message_descriptor_data());
            messages.push(Pair::generated_message_descriptor_data());
            messages.push(Pool::generated_message_descriptor_data());
            messages.push(DepositRequest::generated_message_descriptor_data());
            messages.push(WithdrawRequest::generated_message_descriptor_data());
            messages.push(Order::generated_message_descriptor_data());
            messages.push(MMOrderIndex::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(PoolType::generated_enum_descriptor_data());
            enums.push(OrderType::generated_enum_descriptor_data());
            enums.push(OrderDirection::generated_enum_descriptor_data());
            enums.push(RequestStatus::generated_enum_descriptor_data());
            enums.push(OrderStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
